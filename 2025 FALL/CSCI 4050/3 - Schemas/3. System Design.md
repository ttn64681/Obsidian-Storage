# Outline
```table-of-contents
```

- Analysis: Focuses on the application domain
- Design: 

# System Design: 8 Issues
1. **Identify Design Goals**
	1. additional NFRs Trade-offs
2. **Subsystem Decomposition**
	1. Layers vs Partitions, etc.
	2. Coherence & Coupling
3. **Identify Concurrency**
	1. Identification of Threads
4. **Hardware / Software Mapping**
	1. 
5. **Persistent Data Management**
	1. 
6. **Boundary Conditions**
	1. 
7. **Software Control**
	1. 
8. **Global Resource Handling**

## Model Diagrams
- Fork Diagram
- Stair Diagram

## Stakeholders have Diff Design Goals
- Tradeoffs:
	- Increase Security, sequentially from user tier to middle tier to data tier
		- Hurts the Performance
	- Increase Performance
	- Want both Security & Performance

- Customer (Client)
	- Low cost
	- Increased productivity
	- Backward compatibility
	- Traceability of requirements
	- Rapid development
	- Flexibility
- Developer/Maintainer
	- Minimum num of errors
	- Maintainability, Readability, Reusability, Adaptability
	- Well-defined Interfaces
- End User
	- Functionality
	- User-friendliness
	- Usability
	- Ease of learning
	- Fault tolerant
	- Robustness
- All: Runtime, Reliability, 

### Common Design Trade-offs
- Functionality vs. Usability
- Cost vs. Robustness
- Efficiency vs. Portability
- Rapid development vs. Functionality
- Cost vs. Reusability
- Backward Compatibility vs. Readability

# Subsystem Decomposition
- **Subsystem**
	- Collection of classes, associations, operations
	- in UML subsystems are modeled as packages
	- objects and classes from object model are "seeds" for the subsystem
	- ex: Admin subsystem vs User subsystem
- **Service**
	- A set of named operations that share a common purpose
	- The original information for services ("seed") are the use cases from the functional model
<span style="background:#fff88f">- **Services are defined during System Design**</span>

Service ex:
![[Drawing 2025-10-07 10.42.28.excalidraw]]

## Subsystem Services vs APIs

### Ex: Notification subsystem
- Service provided by Notification Subsystem
	- LookupChannel()

- Ex: User Class
	- 
## Subsystem Properties
- Layers:
- Partition:

- **Multilayer-Architectural Design:**
	- Each layer only talk with direct next layer

- **you can split database access layer into components:**
	- User database access
	- Inventory database access

- THIS IS IMPORTANT because it **reduces tight coupling**
	- enforces *Separation of Layers*
	-  With *bad subsystem decomposition*, if you change one layer, you need to change all other layers

## Good Design: The System as set of Interface Objects


# Architectural Design
## Architectural Design Decisions
## Architecture reuse
## Architectural Style/Patterns vs. Architecture
- Patterns:
	- Client-Server
	- Peer-2-Peer
	- Event-Driven

## Client/Server Style
- Client initiates communication, Server responds
- Client knows about Server, Server knows nothing about Client

- Checking email
	- PC is client
	- Server is outside email manager for distributing emails
- Searching movie
	- Application is client - you search w/in db
	- Server is DB server to provide movie tuples
### Problems w/ Client/Server
- do not provide p2p communication
- p2p communication is often needed
- Ex:
	- Database must process queries from an app and should be able to send notifs to the app when data has changed
- If you want Admin 


## Relationship Client/Server & P2P
- Problem statement "Clients can be servers and servers can be clients"
- Which model is correct?
- Model 1: "a peer can be either a client or a server"
- Model 2: "a peer can be both a client and a server"
	- inheritance : "either-or"
	- ![[Drawing 2025-10-09 10.29.35.excalidraw]]

## Building Systems as a Set of VMs
- A system organized into distinct layers (VMs), where each layer provides services _only_ to the layer directly above it.
- **Examples:**
    - **Networking (OSI Model):** Layers build on services below, abstracting complexity.
    - **Operating Systems:** In an OS (Windows, Linux, macOS), separate:
	    - Kernel (lowest) secures hardware, it's the core component of OS managing CPU, memory, devices, and security; 
	    - Shell  (highest) is interface (Command)offers abstract, safe interaction.
- This is known as **Closed Architecture (Opaque Layering) principle**
## Closed Architecture (Opaque Layering) principle
- Each VM can only call operations from the layer below

- **Design Goals:**  
	- **Maintainability:** Clear boundaries, reduced coupling.  
	- **Flexibility:** Easier to update/replace layers independently.  
	- **Security:** Critical components are isolated in lower, protected layers.

-  more closed architecture -> higher maintainability/flexibility/security

## 3-Layer Style / 3-Tier Architecture
- **3-Tier Architecture** usually refers to 3 hardwares - Client Tier, Business Tier, and Database Tier
- **3-Layer Style** in general divides a system into three logical, distinct tiers:  
    1. **Client Tier (User Interface):** Interacts with the user (e.g., web browser, mobile app).  
    2. **Business Tier (Application Server):** Contains application logic and processes data (e.g., web/app server).  
    3. **Data Tier (Database Server):** Stores and retrieves data (e.g., database).
- Ex: Website Design

## OSI Model
- A conceptual framework that standardizes communication functions of a telecommunication or computing system without regard to their underlying internal structure and technology.

## Pipes and Filters Style
- **System Design Pattern:** Organizes a system as a chain of independent processing elements ("filters").
- Each filter takes input, transforms it, and passes the output to the next filter in sequence.
- **Goal:** High throughput for sequential data processing, promoting reusability and modularity.
- **Example (Compiler Stages):** A compiler processes source code through a pipeline:
    - **Lexical Analysis (Filter 1):** Breaks code into tokens.
    - **Syntax Analysis (Filter 2):** Checks grammar and builds a syntax tree.
    - **Semantic Analysis (Filter 3):** Checks meaning (e.g., type compatibility, using a symbol table).
    This sequence clearly shows how output from one stage (filter) becomes input for the next.

## Facade Style
- User Interface Object