```
public class BurgerFactoryRegistry {
	private static final Map<String, BurgerFactory> registry = new HashMap<>();
	
	// define private constructor since all methods are static.
	private BurgerFactoryRegistry() {}
	public static void registerFactory(String type, BurgerFactory factory) {
		registry.put(type.toLowerCase());
	}
}

public class Main {
	public static void main(String[] args) }
		BurgerFactoryRegistry.registerFactory("beef", new BeefBurgerFactory());
		BurgerFactoryRegistry.registerFactory("veggie", new BeefBurgerFactory());
		
		Scanner scanner = new Scanner(System.in);
		System.out.println("Choose your burger: beef or veggie");
		String choice
}

-> Violates Open-Closed : Have to open client code to add, e.g., "chicken" burger
```

### Moving Registration Out
```
public
```

### Final OCP-Compliant Main Method
```
public class Main {
	public static

}




```

## Cons
- Class explosion
- If you need different types of objects/items to create
	- Prototyping is good for cloning new objects


## Context Used
- Don't know what item you create at runtime

## Can the code break if an expansion is required
- What if we open another restaurant that prepares the same recipes but in an Italian way?

### Abstract Factory
- MacOS vs Windows
- Client requests object, the Abstract Factory gives you MacOs/Windows object