```table-of-contents
```

# Intro
- Previous modules:
	- **System Design** - High-level arch (Components, services, modules)
	- **OOP** - class-level structure, relationships (aggregation, inheritance, etc.)
	- **SOLID Principles** - Best practices for writing individual classes and interfaces
		- **S.** ingle Responsibility - *1 responsibility; 1 reason for the class to change*
		- **O.** pen-Closed - Classes are *OPEN for extension*, *CLOSED for change*
		- **L.** iskov Dubstitution - *All adapters implement the same interface and can be used interchangeably.* 
			- Not have any errors when you exclude a subsystem via inheritance
		- **I.** nterface Segregation - *Classes should not be forced to implement a method that does not apply to its behavior* , Ex: interface implemented by 2 classes, but does not apply to those 2 classes; 
			- Shape interface has getVolume() implemented by Square and Sphere, but Square doesn't have volume
		- **D.** ependency Inversion - *Classes should depend on abstractions, not concretions*
			- Ex: one class conditionally invokes class1 and class2
				- class1 and class2 should not be invoked via concrete class, but instead interface
			- Code is stronger. Violating this also violates open-closed principle
	- **Design Principles** -
		- *Cohesion:*
			- **High** - *1 responsibility only*, View doesn't access Model, speaks to Database Access Layer, which accesses Model
			- **Medium** - Ex: 2 components coupled but are logically related
			- **Low** - More than 1 responsibility with components not logically related
				- access to more than 1 layer

	- **Open-Closed Principle and Dependency-Inversion**
		- Help with:
			- *Protection from variations*

- This Module:
	- **Design Patterns**

# Design Patterns
- **A design pattern is a recurring solution to a standard problem, in a context**
- You will find structure, but not the solution
- Not complex arch design, Design Pattern is just a description:
	- "Descriptions of communicating objects"
- "I want customer to have one shopping cart, and accesses the same cart no matter what or where they are"
	- Singleton Design Pattern
- "I use external API to get movies. In future I might change API, and I want my code to adapt to this."
	- Adapter Design Pattern
- "I want to control access to an object, or add behavior before/after its operations, without modifying the object itself."
    - Proxy Design Pattern
    - **"lazy creation"**
- "I need to create objects, but the exact type to create depends on certain conditions, and I want to defer object creation to subclasses."
    - Factory Design Pattern
- "I need to ensure that only one instance of a specific class exists throughout my application, for example, a central configuration manager."
    - Singleton
    - **"lazy creation"**
- "I need to construct a complex object step-by-step, where the object can have many optional parts, and I want to produce different types and representations of the object using the same construction process."
    - Builder Design
- "I need to create families of related objects (e.g., UI elements for a specific theme or operating system) without specifying their concrete classes."  
    - Abstract Factory


## Practical Use Case
- Imagine you're developing a system that integrates w/ multiple 3rd-party services. Each service has unique API, and you want to standardize the way your system interacts w/ them.
```
void ProcessPayment(double amount) {
	PaymentProcessor P = getPaymentType();
	switch(P) {
		case PAYPAL {
			PayPalAPI.sendPayment(amount);
			break;
		}
		case STRIPE {
			PayPalAPI.sendPayment(amount);
			break;
		}
		case SQUARE {
			PayPalAPI.sendPayment(amount);
			break;
		}
	}
}
```
- Problem:
	- violates Open-Closed Principle
	- Every time new payment service, you need to change concrete class
- Solution:
	- Need ADAPTER 
	-  adapter can take multiple input plug types and still result in same output - charge device/ power device
		- allows incompatible interfaces to work together
		- wraps existing class w/ a new interface that system expects

### Solution:
I Payment Processor Class w/ processPayment(amount), is implemented by:
- PayPalAdapter class
	- has own processPayment(amount) function
- StripeAdapter class
	- has own processPayment(amount) function
- SquareAdapter class
	- has own processPayment(amount) function

## Design Patterns Elements
- Design patterns have 4 basic elements:
	- Pattern name:
	- Problem:
	- Solution:
	- Consequences:

## Benefits of Design Patterns
- Patterns explicitly capture expert knowledge and design tradeoffs and make it more widely available
- Design patterns enable large-scale reuse of software architectures and also help document systems
- Pattern names form a common vocabulary
	- Using terms like **Observer** or **Singleton** creates instant understanding among developers
	- *Ex: "Factory" -> SuperClass, inherited by xyz, like if you want to use Factory to create "Tickets: Child, Adult, Senior"*


# Three Types of Patterns:
- **Creational Patterns**
	- need to create a bunch of objects, complex objects
- **Structural Patterns**
	- behavioral design patterns
	- How to decouple classes
# Creational Patterns
- need to create a bunch of objects, complex, expensive objects
	- constructor may have like 40 attributes, which becomes a complex creational problem
		- Use ->
	- Want to create a lot of things but won't know the things until runtime
		- Use -> Factory Design Pattern
## Singleton
- Intent:
	- Ensure class has only one instance, and provide a global point of access to it
- Motivation:
	- Don't want to create multiple objects that are complex or expensive
- Ex: "Want to create a single large object, that you don't want to create more than once"
	- Sorta like having static variable, but this solution of single class is better
- Ex: 
	- there can be many printers in a system, there should be only one printer spooler
	- there should be only one object with a large state *internal data*
	- creating lots of objects can take a lot of time
	- extra objects take up memory
	- it is cumbersome to deal w/ diff objects "floating" around if they're essentially the same
- Ex:
	- Some systems prevent you from creating +20 connections to database in pool

### Database Connection Singleton Pattern
- Application -> DatabaseConnection (Singleton Instance) -> Database Server

| Singleton                                        |
| ------------------------------------------------ |
| <u>-instance: Singleton</u>                      |
| -Singleton()<br><u>+getInstance(): Singleton</u> |

| DBConnectionSingleton                                                    |
| ------------------------------------------------------------------------ |
| <u>-instance: DBConnectionSingleton</u>                                  |
| -DBConnectionSingleton()<br><u>+getInstance(): DBConnectionSingleton</u> |
- need static instance and static getInstance so you can call it anywhere in code w/o creating object 
	- *(e.g. SignalBus.getInstance())*
### Interaction Between Objects
### Adapting Singleton Pattern to Multi-Threading Environment
- have to have singleton as a Volatile Instance / Volatile Singleton
- And would have to improve code to have singleton stored locally to improve performance

## Factory Method
- Used to replace class constructors, abstracting the process of object generation so that the type of the object instantiated can be determined at run-time
- Separating the object construction from the client code
- " I have 20,000 levels for a game, do I need 20,000 classes? "
	- NO. use one constructor, and based on runtime, then you change the initialization 

- Related to Abstract Factory
- Product is an interface
- ConcreteProduct instances can be created
- FactoryMethod() of the Creator interface returns a Product obkect, but which ConcreteProduct is actually created (the actual constructor call) is hidden in the ConcreteCreator

### Ex 1:
```
/* Two ways to create Object */

1. User user = new SilverUser

2. User user = UserFactory.create(Silver, name)
```

1. what is wrong with this:
	1. violates:
		1. open-closed - have to open user class to add more user conditionals
		2. dependency inversion - users invoke concrete user classes instead of invoking abstract 
			1. you won't know the specific item until runtime


```
Client -> Creator class
Creator class (abstract):
	+ CreateUser()
UserCreator (concrete) extends Creator class:
	+ CreateUser()
```

### Factory Method (Idiom): Factory Item
- Different from Factory Method
	- You refactor weak code into one instance instead of many
	- Solves Dependency Inversion violation

- Ex:
	- RegularUser, GoldUser, PlatinumUser
```
Client code:
if (cond1)
	User user = new RegularUser()
elif (cond2)
	User user = ...
...

```
- Problem: Dependency Inversion violation

- Client invokes the proper constructor

- You refactor that weak code into one Creator interface and UserCreator concrete class

### Factory Method Pattern: Structure
![[Drawing 2025-10-21 10.43.23.excalidraw]]

- Ex: Restaurant Class
	- BeefBurger class or VeggieBurger class
	- multiple if else statements
	- violates Open-Closed Principle
	- violates Single Responsibility
		- Restaurant should just be a class defining restaurant managing actions,
			- not deciding and creating specific types of burgers
		- Restaurant class would need to change for 2 distinct reasons
	- instead -> separate Burger Creation logic into "Burger Factory" or something similar
		- abstract BurgerFactory, concrete BeefBurger Factory, concrete VeggieBurgerFactory,
## Builder Design

## Abstract Factory

## Builder

## Bridge
- for backwards compatibility

# Structural Patterns
## Proxy
- "Proxy" - **substitute, acts as convenient surrogate/placeholder for another object**
	- Ex: "Out of Office Automatic Reply Bot" is a proxy for Teacher/Staff member
	- Ex: Firewall that connects to url - 
		- firewall gets the request, and directs you actual website or will not allow your ip address

- *Putting some object in the middle of two others, to decouple the objects*

- Examples:
	- Restricted websites for some users based on privileges
### Virtual Proxy: 
- Represents a large object
- is used when:
	- the real object is expensive to create or retrieve (e.g., remote data, large files).
	- We want to delay the creation/fetching of that object until it's needed.
	- We may cache or batch-load content to improve performance.
- **Goal:** Performance
- **Ex**: Load Chat History (Lazy fetching)
	- Proxy can just get 10 things, until user requests more, then it contacts actual model for more
	- 
### Protected Proxy:
- Protects access to original object
- Proxy is put in the middle
- **Goal:**

### Remote Proxy:
- 
- **Goal:



## Adapter and Decorator
- The adapter pattern lets classes work together that could not otherwise because of incompatible interfaces
	- "Convert the interface of a class into another interface expected by a client class."
	- Used to provide new interfaces to existing legacy components (Interface engineering, reengineering)
- Object adapter:
	- Uses single inheritance and delegation otherwise because of incompatible interfaces
- Intent:
	- Convert the interface of a class into another interface clients expect
	- Adapter lets classes work together, that could not otherwise because of incompatible interfaces
- Structure
	- ![[Drawing 2025-10-23 10.21.22.excalidraw]]




## Facade
- Provides a unified interface to a set of objects in a subsystem
- A facade defines a higher-level interface that makes the subsystem easier to use (i.e. it abstracts out the "gory details")
- Facades allow us to provides a closed architecture
	- "Less spaghetti code"

### When to Use Facade?
- 

## Decorator
- user interface, the user pages
- to turn one form into another form
![[Drawing 2025-10-28 10.02.31.excalidraw]]

- choose between factory or decorator for creating ticket-types

- examples of decorators (not required):
	- add a snack or recliner to booking ticket

### When to use Decorator?
- 

