```table-of-contents
```


# Requirements Engineering
## What is a Requirement?
- a requirement is a statement of one of the following:
	1. **What a system must do**
	2. *A known limitation or constraint on resources or design*
	3. *How well the system must do what it does*
- The first definition is for **Functional Requirements** 
- The second and third definitions are for *Non-Functional Requirements*

## Types of Requirements
- **Functional Requirements**
	- Describe the interactions b/w the system and its env independent from the implementation
		- "An operator must be able to define a new game"
	- *Describe user tasks that the system needs to support*
	- *Phrased as actions*
- **Nonfunctional Requirements**
	- Aspects not directly related to functional behavior.
		- "The response time must be less than a second"
	- *Describe properties of system or domain*
	- *Phrased as constraints or negative assertions*
		- "A system crash should not result in data loss"
- **Constraints**
	- Imposed by the client or the env
		- "The implementation lang must be Java"
		- "The persistence module must use POSTGRES RDBMS"
	- Also called "Pseudo requirements"

## Types of Nonfunctional Requirements
1. **Quality requirements**
2. **Constraints or Pseudo requirements**

#### Quality requirements
- **Usability**
	- "the ease with which actors can use system to perform a function"
	- must be *measurable*, otherwise it is marketing
		- *"Spectators must be able to watch a match w/o prior registration and w/o prior knowledge of match"*
- **Reliability**
	- *Robustness*
		- Fault is specified
		- ability of a system to maintain a function ->
			- even if user enters wrong input
			- even if there are changes in env
	- *Fault Tolerance*
		- Still able to run despite errors
	- *Availability*
		- the ratio of expected uptime of system to the aggregate of expected up and down time
			- "System is down not more than 5 mins per week"
	- Safety
	- Security
- **Performance**
	- Response time
	- *Throughput* - how many x actions can be done in y time
- **Supportability**
	- Adaptability
	- *Maintainability*
	- Modifiability

#### Constraints or Pseudo Requirements
- Implementation (must be in C++)
- Interface (must be Web-based)
- Operation
- Packaging
- Legal
	- Licensing (GPL, LGPL)
	- Certification
	- Regulation

### Product-oriented attributes
- Performance
- Usability
- Efficiency
- Reliability
- Security
- Robustness
- Adaptability
- Scalability
- Cost
### Product family-oriented attributes
- **Portability:** does it work for several platforms
- **Modifiability**: addition of new functionalities
- **Reusability**: of components, code designs, and even requirements in other systems

### Process-oriented attributes
- **Maintainability:** changes to functionalities, repairs
- **Readability:** of code, documents
- **Testability:** ease of testing and error reporting
- **Understandability:** of design, architecture, code
- **Integrability:** ability to integrate components

### Nonfunctional Requirements Examples
- "Spectators must be able to watch a match w/o prior registration and w/o prior knowledge of match"
	- Usability - ease of use
- "The system must support 10 parallel tournaments"
	- Performance - throughput/capacity
- "The operator must be able to add new games w/o modifications to the existing system"
	- Supportability - ***the ease and impact of making changes/additions to system -> Maintainability***

## Functional Requirements
- System, structure, implementation technology
- Development methodology
- Development env
- Implementation lang
- Reusability

## Requirements Validation
- Requirements Validation is a **quality assurance step**, usually performed after requirements elicitation or after analysis
- **Correctness**
	- the requirements represent the client's views
- **Completeness**
	- All possible scenarios (or user stories), in which system can be used, are described
- **Consistency**
	- There are no requirements that contradict each other
- **Clarity**
	- Requirements can only be interpreted in 1 way
- **Realism**
	- Requirements can be implemented and delivered
- **Traceability**
	- Each system behavior can be traced to a set of functional requirements
- **Verifiability**
	- Should be written so that they could be tested

### Problems w/ requirements validation:
- Requirements change quickly during requirements elicitation
- Inconsistencies are easily added w/ each change
- Tool support is needed

## Verifiable Non-Functional Requirements


## Performance Measures
- Lots of measures:
	- Response Time, Number of events processed/denied in some interval of time, throughput, capacity, usage ratio, jitter, loss of info, latency...
	- Usually w/ probabilities or confidence interval
	- Examples of performance requirement:
		- System shall be able to process 100 payment transactions per sec in peak load

## Reliability Measures:
- Measure degree to which system performs as required
	- Includes resistance to Failure
	- Ability to perform a required function under state conditions for specified period of time
- Can be measured using:
	- Probability that system will perform its required function for a specified interval under stated conditions
		- Mean-time to failure
		- Defect rate
		- Degree of precision for computations

## Availability Measures
- Definition: Percentage of time that the system is up
and running correctly
- Can be calculated based on Mean-Time to Failure
(MTBF) and Mean-Time to Repair (MTTR)
	- **MTBF** : Length of time between failures
	- **MTTR** : Length of time needed to resume
	operation after a failure
		**Availability = MTBF/(MTBF+MTTR)**
	- May lead to architectural requirements
	- Redundant components (lower MTBF)
	- Modifiability of components (lower MTTR)
	- Special types of components (e.g., self-diagnostic)

## Security Measures:
- at least 2 measures
1. The ability to resist unauthorized attempts at usage
2. Continue providing service to legitimate users while under denial of service attack ( resistance to DoS attacks )

## Security: Measurement Methods
- Success rate in authentication
- Resistance to known attacks (to be enumerated)
- Time/efforts/resources needed to find a key (probability of finding the key)
- Probability/time/resources to detect an attack
- Percentage of useful services still available during an attack
- Percentage of successful attacks
- Lifespan of a password, of a session
- Encryption level

## Requirements Management
**Functional requirements:**
- Store the requirements in a shared
repository (user stories are often pinned
on a large board)
- Provide multi-user access to the
requirements
- Automatically create a specification
document from the requirements
- Allow change management of the
requirements
- Provide traceability of the requirements
throughout the artifacts of the system
**Nonfunctional Requirements**
(Questions to overcome "Writers block")
*User interface and human factors*
- What type of user will be using the system?
- Will more than one type of user be using the
system?
- What training will be required for each type of
user?
- Is it important that the system is easy to learn?
- Should users be protected from making errors?
- What input/output devices are available
*Documentation*
- What kind of documentation is required?
- What audience is to be addressed by each
document?


## Prioritizing Requirements
- **High Priority**
	- Addressed during analysis, design, and implementation
	- A high-priority feature must be demonstrated
- **Medium Priority**
	- Addressed during analysis and design
	- Usually demonstrated in second iteration
- **Low Priority**
	- Addressed only during analysis
	- Illustrates how the system is going to be used in future w/ not yet available technology


## Different Types of Requirements Elicitation
- Greenfield Engineering
	- starts from scratch, no prior system exists, requirements come from end users and clients
- Re-engineering
	- 
- Interface Engineering
	- 


## Requirements Engineering





<hr>
## The Working Parts
- **Backlog:**
	- an ordered, ever-evolving document of list of items needed to build a product/service
	- Ex:
		- technical tasks
		- user stories
		- bug fixes
		- new features
	- Goal: Provide shared understanding of what's next, facilitate planning and prioritization, and ensure team is working on most valuable and important items of product
 
### Categories:
- Epic
- User Stories
- Features / Tasks
## Software Requirements Specifications
- **outlines the purpose, behavior, and functionality of a software application**
- **Often includes a "Use Case Doc"**

- Clear and structured description of the software's
	- purpose,
	- scope,
	- functional requirements,
	- non-functional requirements (like performance and quality attributes),
	- external interfaces,
	- constraints, and
	- acceptance criteria

- Includes:
	- high-level Epics:
		- describe large bodies of work ->
	- specific Features:
		- detail functionality ->
	- detailed User Stories:
		- from an end-user perspective
- Each level incorporates Acceptance Criteria to define successful Completion:

- **User Stories:**
	- Describes the why and what behind
	- Ex:
		- **"As** Max, **I want** to invite my friends, **so** we can enjoy this service together."
		- "As Sascha, I want to organize my work, so I can feel more in control."
		- "As a manager, I want to be able to understand my colleagues progress, so I can better report our sucess and failures."
- **Use Case Doc:**
	- **Actors:** The users or other systems that interact with the system being designed. 
	- **Goals:** The objectives that the actor is trying to achieve by interacting with the system. 
	- **Interactions:** The sequence of steps, inputs, and outputs that occur between the actor and the system to accomplish the goal. 
	- **Flows:** The various ways a use case can unfold, including a primary (or "basic") flow of events, and alternate or exceptional flows that handle variations or errors. 
	- **Pre-conditions & Post-conditions:** Conditions that must be true before the use case begins and conditions that must be true after it completes successfully or with an error.

<hr>

# Requirements Flow:

**Product Backlog Refinement (Ongoing):**
- This is a continuous process where the Product Owner and the Development Team add, update, and prioritize Product Backlog items (user stories). 

**Sprint Planning (At the start of each sprint):**
- The team selects items from the Product Backlog and creates the Sprint Backlog, defining what can be delivered in the upcoming sprint. 

**During Development (Throughout the sprint):**
- **User stories** and **acceptance criteria** are refined and elaborated on (on the same product backlog item) as the team works to understand the requirements better and adapt to new insights. 

**After the Sprint (For deliverables):**
- Documentation like **user manuals** or **operational guides** is often created at the end of a sprint or as a release approaches, to support the working software
