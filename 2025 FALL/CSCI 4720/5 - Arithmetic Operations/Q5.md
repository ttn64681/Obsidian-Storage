
### **Question 1 (15 points)**

**Select the equivalent number (in decimal) that is represented by the single-precision floating-point for the given IEEE 754:** **`1 01111000 10100000000000000000000`**

This is an **IEEE to Decimal** conversion (subtract bias).

1. **Deconstruct the 32-bit Number:**
    
    - **S (Sign)** = **1** (The number is **negative**)
        
    - **Exponent (8 bits)** = **`01111000`**
        
    - **Fraction (23 bits)** = **`10100000000000000000000`**
        
2. **Find the Actual Exponent (reverse biasing):**
    
    - First, convert the 8-bit Exponent from binary to decimal: `01111000` = 64 + 32 + 16 + 8 = **120**
        
    - Next, subtract the Bias (which is **127** for single precision, from `M5.3.pdf`, Page 4): `Actual Exponent = 120 - 127 =` **-7**
        
3. **Find the Significand (1 + Fraction):**
    
    - The `Fraction` bits are `1010...`
        
    - This represents the binary fraction `0.101`
        
    - Convert the binary fraction to a decimal: `0.101` (binary) = (1 * 2⁻¹) + (0 * 2⁻²) + (1 * 2⁻³) = 0.5 + 0 + 0.125 = **0.625**
        
    - `Significand = 1 + Fraction` = `1 + 0.625 =` **1.625**
        
    - _(This uses the "hidden bit" rule from your notes: `x = (-1)^S * (1 + Fraction) * 2^(Exponent - Bias)`)_
        
4. **Calculate the Final Number:**
    
    - `Number = (-1)^S * (Significand) * 2^(Actual Exponent)`
        
    - `Number = (-1)^1 * (1.625) * 2^(-7)`
        
    - `Number = -1 * 1.625 * (1 / 128)`
        
    - `Number = -1.625 / 128`
        
    - `Number =` **-0.0126953125**

<hr>

```
# --- Assumptions ---
# $s0 - holds memory addr of 'num1'
# $s1 - holds memory addr of 'num2'
# $s2 - holds memory addr of 'num3'

main:
# 1. load the two single-precision floats from memory
lwc1 $f0, 0($s0) # load num1 into float reg $f0
lwc1 $f2, 0($s1) # load num2 into float reg $f2

# 2. compare if num1 > num2 (by checking !(num1 <= num2))
c.le.s $f0, $f2 # set FP condition flag if $f0 <= $f2

# 3. branch if condition is true (if num1 <= num2, skip the add)
bc1t skip_add # branch if (num1 <= num2) is true

# 4. add the numbers (this code only runs if num1 > num2)
add.s $f4, $f0, $f2 # $f4 = $f0 + $f2 (single precision)

# 5. save the result in num3
swc1 $f4, 0($s2) # store result from $f4 into num3's address

skip_add:
# 6. exit the program
li $v0, 10 # exit
syscall
```

<hr>



<hr>

| **Iteration** | **Step**                       | **Multiplier** | **Multiplicand** | **Product** |
| ------------- | ------------------------------ | -------------- | ---------------- | ----------- |
| **0**         | Initial values                 | 1010           | 0000 0111        | `0000 0000` |
| **1**         | 1: LSB is 0 => No op           | 1010           | `0000 0111`      | `0000 0000` |
|               | 2: Shift Mcand left            | 1010           | `0000 1110`      | `0000 0000` |
|               | 3: Shift Mplier right          | 0101           | `0000 1110`      | `0000 0000` |
| **2**         | 1: LSB is 1 => Prod=Prod+Mcand | 0101           | `0000 1110`      | `0000 1110` |
|               | 2: Shift Mcand left            | `0101`         | `0001 1100`      | `0000 1110` |
|               | 3: Shift Mplier right          | `0010`         | `0001 1100`      | `0000 1110` |
| **3**         | 1: LSB is 0 => No op           | `0010`         | `0001 1100`      | `0000 1110` |
|               | 2: Shift Mcand left            | `0010`         | `0011 1000`      | `0000 1110` |
|               | 3: Shift Mplier right          | `0001`         | `0011 1000`      | `0000 1110` |
| **4**         | 1: LSB is 1 => Prod=Prod+Mcand | `0001`         | `0011 1000`      | `0100 0110` |
|               | 2: Shift Mcand left            | `0001`         | `0111 0000`      | `0100 0110` |
|               | 3: Shift Mplier right          | `0000`         | `0111 0000`      | `0100 0110` |

`# Convert 23.25 to IEEE 754 Single Precision`

`# 1. Sign (S)` `# Number is positive` `S = 0`

`# 2. Binary Conversion` `# 23 (integer) = 16 + 4 + 2 + 1 = 10111` `# 0.25 (fraction) = 1/4 = 0.01` `# Combined binary = 10111.01`

`# 3. Normalization` `# Need to get 1.xxxx format` `# Move decimal 4 places left: 1.011101` `# Exponent becomes 4` `# Normalized number = 1.011101 * 2^4`

`# 4. Find Fraction and Actual Exponent` `# Fraction = 011101 (bits after the '1.')` `# Actual Exponent = 4`

\# 5. Calculate Biased Exponent ` ` # Bias = 127 for single precision ` # Biased Exponent = 4 + 127 = 131` `# Convert 131 to 8-bit binary: 128 + 2 + 1 = 10000011

/# 6. Assemble the 32-bit Number ` ` # S | Exponent | Fraction ` ` # 0 | 10000011 | 011101... (padded to 23 bits)

0 10000011 01110100000000000000000

| **Iteration** | **Step**                       | **Multiplier** | **Multiplicand** | **Product** |
| ------------- | ------------------------------ | -------------- | ---------------- | ----------- |
| **0**         | Initial values                 | 1010           | 0000 0111        | 0000 0000   |
| **1**         | 1: LSB is 0 => No op           | 1010           | 0000 0111        | 0000 0000   |
|               | 2: Shift Mcand left            | 1010           | 0000 1110        | 0000 0000   |
|               | 3: Shift Mplier right          | 0101           | 0000 1110        | 0000 0000   |
| **2**         | 1: LSB is 1 => Prod=Prod+Mcand | 0101           | 0000 1110        | 0000 1110   |
|               | 2: Shift Mcand left            | 0101           | 0001 1100        | 0000 1110   |
|               | 3: Shift Mplier right          | 0010           | 0001 1100        | 0000 1110   |
| **3**         | 1: LSB is 0 => No op           | 0010           | 0001 1100        | 0000 1110   |
|               | 2: Shift Mcand left            | 0010           | 0011 1000        | 0000 1110   |
|               | 3: Shift Mplier right          | 0001           | 0011 1000        | 0000 1110   |
| **4**         | 1: LSB is 1 => Prod=Prod+Mcand | 0001           | 0011 1000        | 0100 0110   |
|               | 2: Shift Mcand left            | 0001           | 0111 0000        | 0100 0110   |
|               | 3: Shift Mplier right          | 0000           | 0111 0000        | 0100 0110   |
