```table-of-contents
```

# Floating Point
- Representation for non-integral nums
	- Including very small and very large nums
- Like scientific notation
	- -2.34 x 10^56
	- +0.002 x 10^-4
	- +987.02 x 10^9
- In binary
	- +=1.xxxxxxx_2 x 2^yyyy
- Types float and double in C

## Floating Point Standard
- IEEE Floating Point Format
- Defined by IEEE Std 754-1985
- Now almost universally adopted
- Two representations
	- Single precision (32-bit)
	- Double precision (  )

## IEEE Floating-Point Format
- 32-bit

|     | single: 8 bits<br>double: 11 bits | single: 23 bits<br> |
| --- | --------------------------------- | ------------------- |
| S   | Exponent                          | Fraction            |
- We first normalize significand: 1.0 â‰¤ | significand | <2.0
	- Always has a leading pre-binary-point 1 bit, so no need to represent it explicitly (hidden bit)
- Exponent: excess representation: **actual exponent + Bias**
	- Ensures exponent is unsigned
	- Single: **Bias = 127**; Double: Bias = 1023

## Floating-Point Ex 1
### Decimal to IEEE (add bias)
- Represent -0.75 = -0.11_2
	- -0.75 = (-1)^1 x 1.1_2 x 2^-1
	- S=1
	- Fraction = 1000...00_2
	- Exponent = -1 +Bias


| S   | Exponent | Fraction               |
| --- | -------- | ---------------------- |
| 1   | 126      | 1000...000 (126 zeros) |
- Exponent = actual exponent + Bias = 127
- **We convert it from -0.11 to Fixed Format IEEE b/c its easier for computer to read**

## Floating-Point Ex 2
### IEEE to Decimal (subtract bias)
- What num is represented by the single-precision float
- 1 100000 0101000...00
	- S = 1
	- Fraction = 01000...00_2
	- Exponent = 10000001_2 = 129
x = -1^1 x (1+01_2) x 2^(129-127)
	= (-1) x 1.25 x 2^2
	**-5.0**

Bias = 127
to find true exponent, reverse biasing ->
129 - 127

## Floating Point Ex 3
- Signed Bit ( 0 or 1) , Bias Exp (8 bits) , Fraction (1.----)
- +/- 

| S   | Exp                  | Fraction                     |
| --- | -------------------- | ---------------------------- |
| 0   | 10000011             | 1010----0 (1010 + 123 zeros) |
|     | 128 + 3<br>131 - 127 |                              |
Exp is 1

131-127 = **4**

1.1010---0
1 + .5 + .125 = **1.625 x 2^4**

## Single-Precision Range
- Exponents 00000000 and 11111111 reserved
- Smallest val
	- Exponent: 00000001
	- -> actual exponent = 1 - 127 = -126
	- Fraction: 000...00 -> significand = 1.0
	- +-1.0 x 2^-126 = +-1.2 x 10^-38
- Largest val
	- Exponent: 11111110
	- -> actual exponent = 254 - 127 = +127
	- Fraction: 111...11 -> significand = 2.0
	- +-2.0 x 2^+127 = +=3.4 x 10^+38

Computer tries to run the result to nearest single precision

What is the reason 0s and 1s are reserved for exponent?
- a special value to be able to print out NaN or Infinity (overflow) or something


# Floating-Point Addition (Binary)
- Now consider a 4-digit binary example
	- 1.000_2 x 2^-1 + -1.110_2 x 2^-2

- This process can be calculated using hardware->
## FP Adder Hardware
- Normal Int Adder -> Half-Adder and Full-Adder
- FP Adder is much more complicated

# Floating-Point Multiplication
- Consider a 4-digit binary ex

## FP Arithmetic Hardware
- FP multiplier is of similar complexity to FP adder
	- But uses a multiplier for significands instead of an adder
- FP arithmetic is

# Floating-Point Instructions in MIPS
- FP hardware is called "Coprocessor 1"
- Adjunct processor that extends the ISA so that FP architecture can be executed
- Separate FP registers
- 32 single-precision: $f0, $f1, ... $f31
- Paired for double precision: \$f0/$ f1, \$f2/$ f3

- MIPS supports the IEEE754 single precision and double precision formats w/
- Floating-point addition, single (add.s) and addition double (add.d)
- Floating-point subtraction, single (sub.s) and subtraction double (sub.d)
- Floating-point multiplication, single (mul.s) and multiplication double (mul.d)
- Floating-point division, single (div.s) and and division double (div.d)

# Floating-Point Comparison
- FP load and store instructions
- lwc1, ldc1, swc1, sdc1
- e.g.,  *ldc1 \$f8, 32(\$sp)*

- Floating-point comparison single (c.x.s) and comparison, double (c.x.d), where x may be equal (eq) , not equal (neq), less than (lt), less than or equal (le), greater than (gt), or greater than or equal (ge)
- Floating-point branch, true (bc1t) and branch, false (bc1f)
	- *Example: c.lt.d $f0, \$f2 # condition of \$f0<\$f2*

## Ex:
- lwc1 $f4,8(\$ sp) # Load 32-bit F.P. number into F4
- lwc1 $f6,a(\$ sp) # Load 32-bit F.P. number into F6
- add.s $f2, \$f4, \$f6 # F2 = F4 + F6 single precision
- swc1 \$f2, 4( $sp ) 

## FP Ex: convert temp in F to C 
- C code:
```
float f2c (float fahr) {
	return ((5.0/9.0) * (fahr - 32.0));
}
```
- fahr in $f12, result in $f0, literals in global memory space
- Compiled LEGv8 code:
```
f2c:
lwc1 $f16, const5(gp) # f16 = 5.0 (5.0 in memory)
lwc1 $f18, const9($gp) # f18 = 9.0 (9.0 in memory)
```


# THE END
- ISAs support arithmetic
	- Signed and unsigned integers
	- Floating-point approximation to reals
- Bounded range and precision
	- Operations can overflow and underflow

