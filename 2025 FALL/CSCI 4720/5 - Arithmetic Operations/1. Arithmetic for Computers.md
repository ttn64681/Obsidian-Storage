```table-of-contents
```

- Operations on integers
	- Addition and subtraction
	- Multiplication and division
	- Dealing w/ overflow
- Floating-point real numbers
	- Representation and operations

## Arithmetic -- The heart of instruction execution
1. Instruction Fetch
2. Instruction Decode
3. Operand Fetch
4. **Execute**
	1. ![[Drawing 2025-10-21 08.03.39.excalidraw]]
5. Result Store
6. Next Instruction

## Review: Basic Hardware
1. AND gate ( a = a . b )
2. OR gate ( c = a + b )
3. Inverter ( c = a )
4. Multiplexor 

## Review: A Simple Multi-Function Logic Unit
- let's build a logic unit to support the AND, OR, and add operations
- how can we use basic gates to design this multi-function logic unit
	- Need AND and OR
	- Need add...
	- Need Multiplexor to SELECT b/w these 2 gates
		- which gates should be used for the final output?

### Implementation w/ a Multiplexor
- Selects one of the the inputs to be the output based on a control input
![[Drawing 2025-10-21 08.07.32.excalidraw]]

### Half Adder
- Half Adder Design:
1. Needs 2 inputs 2 outputs
2. Truth table:

| x   | y   | C   | S   |
| --- | --- | --- | --- |
| 0   | 0   |     |     |
| 0   | 1   |     |     |
| 1   | 0   |     |     |
| 1   | 1   |     |     |
| 0   | 0   |     |     |
| 0   | 1   |     |     |
| 1   | 0   |     |     |
| 1   | 1   |     |     |

### Full Adder
- we need Full Adder to have carry bit for proper addition arithmetic

| x   | y   | C_in | C_out | S   |
| --- | --- | ---- | ----- | --- |
| 0   | 0   | 0    | 0     | 0   |
| 0   | 0   | 1    | 0     | 1   |
| 0   | 1   | 0    | 0     |     |
| 0   | 1   | 1    | 1     |     |
| 1   | 0   | 0    | 0     |     |
| 1   | 0   | 1    | 1     |     |
| 1   | 1   | 0    | 1     |     |
| 1   | 1   | 1    | 1     |     |
### 1-Bit Adder Logic

### Building a 32-bit ALU
- 1-bit ALU for AND, OR, and add
- Ripple-Carry Logic for 32-bit ALU
	- CarryIn is input for Multiplexor

- **Basically, combine multiplexer and full adder to achieve 1-Bit Adder**

## How to design Subtraction Logic ALU?
- 7-6 turns into 7 + (-6)
- This means we can use Ripple-Carry Full Adder, but negate second operand
	- Two's Complement: invert all bits and add 1
	- Add Two's Complement to first operand
	- Integer Overflow

- *6 -> 0110 -> 1001 + 1* = **1010 = -8+2 = -6**
- 7 -> 0111
- + -> 1010
- = -> 10001 -> overflow -> 0001 -> 1

## Integer Subtraction
- Add negation of second operand
- Ex: 7-6 = 7 + (-6)
- +7: 0000 0000 ... 0000 0111
- -6:  1 1 1 1   1 1 1 1  ...  1 1 1 1  1010
- +1: 0000 0000 ... 0000 0001
## What about Subtraction (A-B)?
- Two's complement approach: just negate b and add
- How do we negate?
	- Recall negation shortcut: *invert each bit of b and set CarryIn to least significant bit (ALU) to 1*

## Detecting Overflow
- **No overflow** *when adding a pos and neg number*
- **No overflow** *when subtracting nums w/ the same sign*
- **Overflow occurs when the result has "wrong" sign (verify!)**
![[Detecting Overflow Chart.png]]
7+6 = 13
- 0111
- 0110
- 1101 = 13

-6 + -4 = -10
- 1010
- 1100
- 10110 -> overflow -> 0110 + 4+2 = 6 

- If carry in and carry out are different, then there is no overflow...

## Support Overflow Detection
- overflow bit = carry in to msb (+) carry *out of* msb
	- logic for overflow detection therefore can be put in to
		- ALU31

## Overflow Detection Logic
![[Overflow Detection Logic.png]]


NOT TOO HARD:
- Finite State Machine
- Circuit
- Truth Table (like the state transition table)
- boolean expression


2. Just the Truth Table