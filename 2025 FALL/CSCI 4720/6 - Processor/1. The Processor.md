```table-of-contents
```
# Intro
- CPU performance Factors
	- Instruction count
		- Determined by ISA and compiler
	- CPI and cycle time
		- Determined by CPU hardware
- We will examine 2 MIPS implementations
	- A simplified version
	- A more realistic pipelined version
- Simple subset, shows most aspects
	- Memory reference: lw, sw
	- Arithmetic/logical: add, sub, and, or, slt
	- Control transfer: beq, j

## Instruction Execution
- For every instruction, the first two steps are the same:
1. Send PC to the memory that contain the code and fetch the instruction
2. Read one (for LW) or 2 registers (for ADD)
	- Depending on instruction class
		- Use ALU to calculate
			- Arithmetic result
			- Memory address for load/store
			- Branch target address
		- Access data memory for load/store
		- PC <- target address or PC + 4

![[CPU Overview.png]]


We need multiplexor to select between multiple data sources
![[REPO/2025 FALL/CSCI 4720/6 - Processor/Pasted Images/Multiplexers.png]]

![[Control.png]]

# Logic Design Basics (Review)
- Info encoded in binary
	- low voltage = 0, high voltage = 1
	- one wire per bit
	- Multi-bit data encoded on multi-wire buses

## Ex of Combinational Logic Elements
![[Combinational Elements.png]]

## D-Flip Flip - Basic Memory Element
![[D Flip Flop.png]]
- Used w/ SR Latch (on the right of logic circuit diagram)
- Can be used to implement Register

## Sequential Elements
- Register: stores data in circuit
	- Uses clock signal to determine when to update the stored value
	- Edge-triggered: update when Clk changes from 0 to 1
![[Clock Ex.png]]

- Register w/ write control
	- Only updates on clock edge when write control input is 1
	- Used when stored val is required later
![[Clock Example Write Control.png]]

# Storage Elements: Register File
- Internal Structure:
	-  Each Registers are implemented w/ arrays of D-flip flops
	- Allows for multiple simultaneous reads and one write
![[Register File - D flip flop.png]]
- Crucial Design for RISC architectures like MIPS:
	- We need 3 registers in order to handle typical instruction formats (like R-Format instructions)
		- 2 read, 1 write ->
		- Register file w/ 2 read ports and 1 write port
			- allow for high parallelism in data access

- We will use this register file to build the Datapath
# Datapath
- The **collection of functional units that perform data processing operations** *and the buses (wires) that connect them.*
- These elements process data and addresses w/in the CPU
- Key components:
	- Registers (like Register file)
	- ALU
	- Memory Units 
	- Multiplexers (to select b/w multiple input signals to produce single output)
	- Adders (Specialized ALUs to calculate PC+4 for branch targets)
- Datapath controlled by the **Control Unit**
	- generates signals based on instruction being executed, telling datapath what to do
## Building a Datapath
- Datapath
	- Elements that process data and addresses in the CPU
		- Registers, ALU, Memory, Multiplexers, Adders

# Instruction Fetch
- shows initial stage of CPU pipelining
- PC - special register that holds memory address of current instruction to be executed
![[Instruction Fetch PC.png]]
1. **Send PC address to instruction Memory**
	- value from PC is used as address to retrieve instruction from Instruction memory
2. **Fetch Instruction**
	- 32-bit instruction word is read from Instruction Memory
3. **Increment PC by 4**
	- why 4? because each MIPS instructions is a fixed-width 32-bit (4-byte) word.
	- Incrementing by 4 prepares the PC to point to the next sequential instruction in memory.
# Animating the Datapath
![[Animating the Datapath 1.png]]
![[Animating the Datapath 2.png]]
![[Animating the Datapath 3.png]]
![[Animating the Datapath 4.png]]
## Overall:
- You need PC to get instruction from Memory, then you increase the PC by 4

# R-Format Instructions
![[R-Format Instructions.png]]
# Animating the Datapath
![[Animating the Datapath.png]]
![[Animating the Datapath two.png]]
![[Animating the Datapath three.png]]
![[Animating the Datapath four.png]]

# Load/Store Instructions
- Read register operands
- Calculate address using 16-bit offset
	- Use ALU, but sign-extend offset
- Load: read memory and update register
- Store: write register value to memory
## Sign Ext for 16-bit to 32-bit
![[Drawing 2025-11-04 08.36.02.excalidraw]]
- increase Signed bit
## Wiring
- 
![[Drawing 2025-11-04 08.41.32.excalidraw]]
- split signed bit wire into multiple

# Animating the Datapath (Load)
![[Animating the Datapath Load 1.png]]
![[Animating the Datapth Load 2.png]]
![[Animating the Datapath Load 3.png]]
![[Animating the Datapath 4-1.png]]
![[Animating the Datapath Load 5.png]]

# Animating the Datapath (Store)
![[Animating the Datapath Store 1.png]]
![[Animating the Datapath Store 2.png]]
![[Animating the Datapath Store 3.png]]
![[Animating the Datapath Store 4.png]]
![[Animating the Datapath Store 5.png]]

## Overview
- we've talked about 2 types of instructions:
1. ...
	- Arithmetic, etc. etc., 
		- we need 3 instructions
2. Memory instructions:
	- Load and store
		- need to calc address and access mem, read or write or whatever
# Branch Instructions
- How to implement Branch Instructions
- Read register operands
- Compare operands
	- Use ALU, subtract and check Zero output
- Calculate target address
	- Sign-extend displacement
	- Add to PC + 4
		- Already calculated by instruction fetch

## Target Addressing Example:
- Loop code from earlier example
	- Assume loop at location 8000
![[Target Addressing Example Code branch instructions.png]]

## Branch Instructions
![[REPO/2025 FALL/CSCI 4720/6 - Processor/Pasted Images/Branch Instructions.png]]

# Animating the Datapath (Branch Instructions)
![[Animating the Datapath branch 1.png]]
![[Animating the Datapath branch 2.png]]
![[Animating the Datapath branch 3.png]]
![[Animating the Datapath branch 4.png]]

- All of this starts from the encoding form the instruction
- which way to read or write, and whats the constant offset
- what kind of operation, sub, add, logical gate, to perform

- here we mainly focus on datapath
- we will talk about the control path

- Absolute branch vs PC relative branch. We are talking about PC relative branch. we will talk about absolute branch later

