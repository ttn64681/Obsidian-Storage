- [ ] Prog proj next tuesday
- [ ] Quiz 6 next wednesday
- [ ] Dec 4 Exam

# MIPS Pipelined DataPath
- execute multiple instructions at same time
- if you divide datapath into 5 stages
	- Instruction Fetch
	- Instruction decode/reg file read
	- Execute/addr calc
	- MEM access
	- Write back
![[MIPS Pipeline DataPath.png]]
- Right to left flow leads to hazards

# Pipeline Operation
-  need register b/w stages
	- to hold information produced in previous cycle
![[Pipeline Operation.png]]
- Cycle by cycle flow of instructions thru the pipelined datapath
	- "Single-clock-cycle" pipeline diagram
		- shows how pipeline usage in single cycle
		- highlight resources used
	- C.f. "multi-clock-cycle" diagram
		- Graph of operation over time
- We'll look at "single-clock-cycle" diagrams for load & store

## IF Load for Store
![[IF Load for Store.png]]
## ID for Load, Store
![[ID for Load or Store.png]]
## EX for Load
![[EX for Load.png]]
## MEM for Load
![[MEM for Load.png]]
## WB for Load
![[WB for Load (Wrong Reg Numb).png]]

## Corrected Datapath for Load
![[Corrected Datapath for Load.png]]

1. then
2. d
3. d
4. then read mem. will be stored in storage
5. Write back for Load

we're executing load in write back state, but were using incorrect register state number. its coming from current execution 
- so, how to get correct register number, so load can write to ...

Corrected Datapath for Load

- at any time at any cycle there is only one instruction that is in the WRite Back State
so that register state number will be used as write number to update register file
- thats why we can pass the information and use that information at right.. state?


# Notes:
- • One significant difference in the execution of an R-type instruction between multicycle and pipelined implementations:
- • register write-back for the R-type instruction is the 5th (the last write-back) pipeline stage vs. the 4th stage for the multicycle implementation.
- • think of structural hazards when writing to the register file…
- • Worth repeating: the essential difference between the pipeline and multicycle implementations is the insertion of pipeline registers to decouple the 5 stages
- • The CPI of an ideal pipeline (no stalls) is 1. Why?

- CPI ideal: we have many isnturctions to fill up piepeline, no bubble, so stores, no branch prediction failures
- at any cycle, we can finish 1 instruction


we can identify when a pipeline is executing data hazard
and if there is data hazard can forward result
how do we implement this

Consider this sequence:
```
sub $2, $1,$3
and $12,$2,$5
or $13,$6,$2
add $14,$2,$2
sw $15,100($2)
```
 We can resolve hazards with forwarding
 - how can we detect hazard? how can we implement forwarding?

# Dependencies & Forwarding
![[Dependencies and Forwarding.png]]

## Detecting the Need to Forward
- Pass register numbers along pipeline
	- e.g., ID/EX.RegisterRs = register number for Rs sitting in ID/EX pipeline register
	- ALU operand register numbers in EX stage are given by
		- ID/EX.RegisterRs, ID/EX.RegisterRt
	- Data hazards when
		**1a.** EX/MEM.RegisterRd = ID/EX.RegisterRs
		**1b.** EX/MEM.RegisterRd = ID/EX.RegisterRt
		**2a.** MEM/WB.RegisterRd = ID/EX.RegisterRs
		**2b**. MEM/WB.RegisterRd = ID/EX.RegisterRt

But only if forwarding instruction will write to a
register!
• EX/MEM.RegWrite, MEM/WB.RegWrite
• And only if Rd for that instruction is not $zero
• EX/MEM.RegisterRd ≠ 0,
MEM/WB.RegisterRd ≠ 0


## Forwarding Paths
![[Forwarding Paths.png]]

## Forwarding Conditions
• EX hazard
• if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0)
and (EX/MEM.RegisterRd = ID/EX.RegisterRs))
ForwardA = 10
• if (EX/MEM.RegWrite and (EX/MEM.RegisterRd ≠ 0)
and (EX/MEM.RegisterRd = ID/EX.RegisterRt))
ForwardB = 10
• MEM hazard
• if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0) and
(MEM/WB.RegisterRd = ID/EX.RegisterRs))
ForwardA = 01
• if (MEM/WB.RegWrite and (MEM/WB.RegisterRd ≠ 0)
and (MEM/WB.RegisterRd = ID/EX.RegisterRt))
ForwardB = 01

## How to Stall the Pipeline
- Force control values in ID/EX register to 0
	- EX, MEM, and WB do nop (no-operation)
- Prevent update of PC and IF/ID register
	- using instruction is decoded again
	- Following instruction is fetched again
	- 1-cycle stall allows MEM to read data for `lw`
		- Can subsequently forward to EX stage
## Stall/Bubble in the Pipeline
![[Stall Bubble in Pipeline.png]]

## Stalls and Performance
- <span style="background:#fff88f">BIG PICTURE:</span>
- Stalls reduce performance
	- But are required to get correct results
- Compiler can arrange code to avoid hazards and stalls
	- Requires knowledge of the pipeline structure

What is speculation:
- technique of performing actions (like fetching or executing instructions) **before it is certain that these actions are actually needed or correct.**
	- **Purpose:** To improve performance by keeping the pipeline full and avoiding stalls, especially for control hazards (branches).
	- **How it works:** The processor makes an educated guess (prediction) about the outcome of an instruction (e.g., a branch direction) and proceeds to execute instructions along the predicted path.
	- **Example:** With a branch instruction, the processor might "speculate" that the branch will be taken (or not taken) and immediately fetch instructions from that predicted target, rather than waiting for the branch condition to be fully evaluated.
	- **Risk:** If the speculation turns out to be wrong (e.g., the branch was predicted "taken" but was actually "not taken"), the work performed under speculation must be discarded.
	- **Recovery:** When a misprediction occurs, the pipeline must be flushed, the correct path's instructions must be fetched, and any speculative state changes must be undone.

- meltdown and spectre attack
- an attack on speculation
