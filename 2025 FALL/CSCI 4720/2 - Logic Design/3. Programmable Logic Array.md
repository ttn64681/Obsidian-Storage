- Programmable logic device
- **Structured** scheme for implementing combinational logic circuits
- Consists of a **set of programmable AND gate planes** linked to a **set of programmable OR gate planes**
- PLA allows for a large number of logic functions to be synthesized in the SOP and POS canonical forms

- Use the PLA to implement the circuit:
![[Programmable Logic Array Ex.png]]
- Number of ANDS = Number of non-repeated minterms
	- 7
- Number of ORs = Number of functions
	- 3

EX: 4 Inputs F=(A,B,C,D) -> Output: Number of 1 bits X,Y,Z

| A   | B   | C   | D   | X_2 | X_1 | X_0 |
| --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| 0   | 0   | 0   | 1   | 0   | 0   | 1   |
| 0   | 0   | 1   | 0   | 0   | 0   | 1   |
| 0   | 0   | 1   | 1   | 0   | 1   | 0   |
| 0   | 1   | 0   | 0   | 0   | 0   | 1   |
| 0   | 1   | 0   | 1   | 0   | 1   | 0   |
| 0   | 1   | 1   | 0   | 0   | 1   | 0   |
| 0   | 1   | 1   | 1   | 0   | 1   | 1   |
| 1   | 0   | 0   | 0   | 0   | 0   | 1   |
| 1   | 0   | 0   | 1   | 0   | 1   | 0   |
| 1   | 0   | 1   | 0   | 0   | 1   | 0   |
| 1   | 0   | 1   | 1   | 0   | 1   | 1   |
| 1   | 1   | 0   | 0   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   | 0   | 1   | 1   |
| 1   | 1   | 1   | 0   | 0   | 1   | 1   |
| 1   | 1   | 1   | 1   | 1   | 0   | 0   |
X_2 = ABCD
X_1 = A'B'CD + A'BC'D + A'BCD' + A'BCDD + AB'C'D + AB'CD' + AB'CD + ABC'D' + ABC'D + ABCD'
X_0 = A'B'C'D _ A'B'CD' + A'BC'D' + A'BCD + AB'C'D' + AB'CD + ABC'D + ABCD' 

## Common Combinational Logic Circuits
- **Half Adder and Full Adder**
- **Ripple-Carry Adder**
- **Decoder**
- **Multiplexer**
- **Demultiplexer**

## Half-Adder (HA)

| A   | B   | S   | C   |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 1   | 1   | 0   |
| 1   | 0   | 1   | 0   |
| 1   | 1   | 0   | 1   |
- **NO carry input**
- **XOR** gate to generate SUM
- **AND gate to generate Carry (C)**
- **generates 1 single bit**
![[Half Adder ex.png]]

## Full Adder (FA)

| A   | B   | C_in | S   | C_out |
| --- | --- | ---- | --- | ----- |
| 0   | 0   | 0    | 0   | 0     |
| 0   | 1   | 0    | 1   | 0     |
| 1   | 0   | 0    | 1   | 0     |
| 1   | 1   | 0    | 0   | 1     |
| 0   | 0   | 1    | 1   | 0     |
| 0   | 1   | 1    | 0   | 1     |
| 1   | 0   | 1    | 0   | 1     |
| 1   | 1   | 1    | 1   | 1     |
![[Full Adder (FA).png]]

- **XOR** of 3 inputs (A, B, C_in) to generate SUM
- **Minterm SOP to generate C_out**
- **generates 1 single bit**

### How is this used to create 32-bit Adder?
- Ripple Carry Adder
## Ripple Carry Adder
![[32 bit adder divided in 4.png]]
![[Ripple Carry Adder.png]]
- this is known as a Ripple Carry Adder
![[Ripple-Carry Adder.png]]
## Decoder
![[Decoder.png]]
![[Decoder For Example.png]]
- Decodes all possible amount of outputs
## Decoder Example
![[Decoder Example.png]]


## Encoder
![[Encoder.png]]

## Encoder Example
![[Encoder Example.png]]

## Priority Encoder
![[Priority Encoder.png]]
- ignores low-priority input signals
## Priority Encoder Example
![[Priority Encoder Example.png]]

## Code Converter
- **Used to convert an n-bit number into another n-bit number**
- **Implemented as a decoder-encoder combination**
- e.g. Y = (X + 3) mod 8 where Y and X are 3-bit numbers
![[Code Converter ex 3 bit.png]]

| X_2 | X_1 | X_0 | Y_2 | Y_1 | Y_0 |
| --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 1   | 1   |
| 0   | 0   | 1   | 1   | 0   | 0   |
| 0   | 1   | 0   | 1   | 0   | 1   |
| 0   | 1   | 1   | 1   | 1   | 0   |
| 1   | 0   | 0   | 1   | 1   | 1   |
| 1   | 0   | 1   | 0   | 0   | 0   |
| 1   | 1   | 0   | 0   | 0   | 1   |
| 1   | 1   | 1   | 0   | 1   | 0   |

## Multiplexers
![[Multiplexers.png]]