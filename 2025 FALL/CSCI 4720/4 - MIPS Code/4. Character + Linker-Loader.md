# Character Data
- ASCII (American Standard Code for Information Interchange)
	- 8 bits
	- Encoding 95 graphics, 33 control
- Unicode: 32-bit character set
	- Used in Java, C++ wide characters, ...
	- Most of world's alphabets, plus symbols
	- Unicode Transformation Format (UTF)
	- UTF-8, UTF-16

## ASCII vs Binary Numbers
- We could represent numbers as strings of ASCII digits instead of as integers
- How much storage increase if the number 1 billion is represented in ASCII vs 32-bit integer?
	- ASCII
		- 1,000,000,000 - takes 10 ASCII digits, **each 8 bits long** 
		- 10 x 8 -> **80 bits**
	- Binary
		- **32-bits**
		- (10x8)/32 = 2.5 storage expansion from binary to ASCII

## Byte/Halfword Operations
- MIPS byte/halfword load/store
	- String processing is a common case
- lb rt, offset(rs)
	- *Load byte* (lb) loads a byte from mem, placing it in the rightmost 8 bits of a register, sign extend to 32 bits in rt
	- e.g., lb $s0, 4($ t0)
- lh rt, offset(rs)
	- *Load* *half* (lh) loads a half word from memoru, placing it in the rightmost 16 bits of a register, sign extend to 32 bits in rt
	- e.g., lh $s0, 4(\$t0)
- lbu rt, offset(rs)
- lhu rt, offset(rs)
	- Zero extend to 32 bits in rt
- sb rt, offset(rs)
	- *Store byte* (sb) takes a byte from the rightmost 8 bits of a register and writes it to.memory
- sh rt, offset(rs)
	- Store just rightmost byte/halfword

![[Drawing 2025-09-25 08.13.11.excalidraw]]

# String Copy Ex
- Procedure strcpy copies string y to string x using the null byte termination convention of C

- High level code
```
void strcpy (char x[], char y[])
{
	int i = 0;
	while ((x[i] = y[i]) != '\0')
		i += 1;
}
```
- Addresses of x, y in $a0, $a1

![[Drawing 2025-09-25 08.16.59.excalidraw]]

- MIPS code
```
strcpy: 
	addi $sp, $sp, -4     # adjust stack for one item
	sw $s0, 0($s0)        # save $s0
	add $s0, $zero, $zero # i = 0
L1: add $t1, $s0, $a1     # 
	lbu $t2, 0($t1)
	add $t3, $s0, $a0
	sb 
```
- this is a **LEAF procedure** : doesn't call any other procedure
	- don't need to save $ra,
- if NON-LEAF
	- need to save $ra, otherwise it will be overwritten

![[Drawing 2025-09-25 08.24.15.excalidraw]]

## Load Upper Immediate Instruction
- Most constants are small
	- 16-bit immediate is sufficient
	lui rt, constant
	- Copies 16-bit constant to left 16-bits of rt
	- Clears right 16 bits of rt to 0

Example: What is MIPS assembly code to load this 32-bit constant into register $s0
0000 0000 0011 1101 0000 1001 0000 0000

lui $s0, 61 

| 0000 0000 0011 1101 | 0000 0000 0000 0000 |
| ------------------- | ------------------- |

ori $s0, $s0, 2304

| 0000 0000 0111 1101 | 0000 1001 0000 0000 |
| ------------------- | ------------------- |
## Branch Addressing
- Branch instructions specify
	- Opcode, two registers, target address
- Most branch targets are near branch
	- Forward or backward
	- bne $t0, $s5, Exit

| op     | rs     | rt    | constant or address |
| ------ | ------ | ----- | ------------------- |
| 6 bits | 5 bits | 5bits | 16 bits             |
- PC relative addressing
	- Target address = PC + offset x 4
	- PC already incremented by 4 by this time

## Jump Addressing
- Jump (j and jal) targets could be anywhere in text segment
	- Encode full address in instruction

| op     | address |
| ------ | ------- |
| 6 bits | 26 bits |

- (Pseudo) Direct jump addressing
	- Target address = PC_31...28: (address x 4)

- this is called ABSOLUTE address
	- when we get jump address, its not relative to PC

## Target Addressing Example
- Loop code from earlier ex:
	- Assume loop at location 80000

```
Loop: s11  $t1,  $s3,  2	
	add $t1, $t1, $s6
	lw
```

At line 4, PC points to next instruction
- always points to next instruction (80016)

## Addressing Mode Summary
- Base or displacement addressing, the operand is at the memory location whose address is the sum of a register and a constant in the instruction

## Synchronization
- 2 processors sharing an area of memory
	- P1 writes, then P2 reads
	- Data race if P1 and P2 don't synchronize
		- Result depends on order of accesses
- Hardware support required
	- Atomic read/write memory operation
	- No other access to the location allowed between the read and write

- Could be a single instruction
	- e.g., atomic swap of register <-> memory
	- Or an atomic pair of instructions

### Data race / Race condition
![[Drawing 2025-09-25 08.54.07.excalidraw]]

## Synchronization in MIPS
- Load linked: ll rt, offset(rs)
- Store conditional: sc rt, offset(rs)
	- Succeeds if location not changed since the 11

While a lock variable itself might be implemented using a primitive data type (like an integer set to 0 for available, 1 for taken), the _concept_ of a lock is a higher-level synchronization construct. Hardware often provides _atomic operations_ (like MIPS `ll`/`sc`) to enable the robust implementation of these synchronization primitives.
### Solution to race conditions: use Atomic operations
**Atomic operations** are operations that appear to be indivisible and uninterruptible with respect to other operations in a concurrent system.

Key characteristics:
- **Indivisible:** They either complete entirely or do not happen at all. There is no partial completion.
- **Uninterruptible:** Once an atomic operation begins, no other process or thread can interfere with it until it is finished.
- **Purpose:** They are crucial for implementing synchronization mechanisms (like locks) to prevent data races and ensure data consistency in multi-threaded or multi-processor environments.

- Example: atomic swap (to test/set lock variable)
- Content of mem that its address is in $s1 and contents of $s4
```
try: add $t0, $zero, $s4  # copy exchange value
	ll $t1, 0($s1)        # load linked
	sc $t0, 0($s1)        # store conditional
	beq $t0, $zero, try   # branch store fails
	add $s4, $zero, $t1   # put load value in $s4
```
## Linker and Loader
*In the context of program execution from source code*
- Compiler outputs is assembly files
- Assembler output is object files
- Linker joins object files into one executable
- Loader brings it into mem and starts execution

## Producing an Object Module
- Assembler (or compiler) translates program into machine instructions
...
## Linking Object Modules
- Read from image file on disk into mem
	1. Read header to determine segment sizes
	2. Create virtual address space
	3. Copy text and initialize data into memory
	4. ...
- Sets up environment

## Dynamic Linking
- Only link/load library procedure when it is called
	- Requires procedure code to be relocatable

## Starting Java Apps
- Compiles bytecodes of "hot" methods into native code for host machine
- Just In Time compiler
	- Compiled Java methods (machine language)
	- -> JVM - interprets bytecodes