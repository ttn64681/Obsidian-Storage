```table-of-contents
```
# Intro:
- **Steps required**
1. Place parameters in registers
2. Transfer control to procedure
3. Acquire storage for procedure
4. Perform procedure's operations
5. Place result in register for caller
6. Return to place to caller

## What to know about function?
- need to know name of function
- need to know func arguments
- need to implement code inside of function body
![[Drawing 2025-09-23 08.03.30.excalidraw]]

## Program Counter (PC)
- Implicit in the stored-program idea is the **need to have a register to hold the address of the current instruction being executed**
- Fore historical reasons, this register is almost always called **Program Counter**
	- abbreviated PC in the MIPS
	- PC is updated for each instruction
		- *typically incremented by 4 (size of a MIPS instruction in bytes)*
	- Branch and jump instructions modify the PC to change the flow of execution
- There is also IP (Instruction Pointer)

## Stack and Stack Pointer
- \$a0 -- \$a3: arguments
- \$v0, \$v1: result values

### 1) What if...?
- *the compiler needs more registers* for a procedure than \$a0 -- \$a3 and 2 return value registers \$v0, \$v1
### 2) Also...?
- what if we have a function that takes more than 4 arguments? don't we have limited amount of register?

- Since we must cover our tracks after the procedure is complete, any registers needed by the caller must be restored to the values that they contained before the procedure was invoked
### 3) Answer: Virtually save these values in the MEMORY
- Memory is much larger than the register
- **Limited number of registers**
- The ideal data structure for spilling registers is a STACK (LIFO)
	- STACK used to pass arguments too

## Stack Instructions Ex:
![[Drawing 2025-09-23 08.17.51.excalidraw]]

## Register Usage
- \$a0 - \$a3: arguments ( )

## Procedure Call Instructions
- Procedure call: jump and link
	jal ProcedureLabel
	- Address of following instruction put in $ra
	- Jumps to target address

- **Call a procedure** - jump and link
	jal ProcedureLabel
	- Address of following instruction put in $ra
	- Jumps to target address
- **Return procedure**: jump register
	jr $ra
	- Copies $ra to program counter
	- Can also be used for computed jumps
		- e.g., for switch/case statements

### Leaf Procedure Example
- a procedure that does NOT call any other procedures (functions)
- **C code (not real, pseudocode)**
``` 
int leaf_example (int g, h, i, j)
{ 
	int f;
	f = (g+h) - (i+j);
	return f;
}
```
- Args: g, h, i, j in $a0, ..., $a3
- f in $s0 (hence, need to save \$s0 on stack)
	- we must save it since not enough space for register
- Result in $v0

- **MIPS code conversion:**
```
addi $sp, $sp, -4    # Decrease sp by 4 since we need to store a byte
sw $s0, 0($sp)       # Save $s0 on stack (f)
add $t0, $a0, $a1    # (g+h)
add $t1, $a2, $a3    # (i+j) Procedure body
sub $s0, $t0, $t1    # (g+h) - (i+j)
add $v0, $s0, $zero  # Result in $v0
lw $s0, 0($sp)       # Restore $s0
addi $sp, $sp, 4     #
jr $ra               # Return
```
- add $v0, $s0, $zero
	- common idiom to move a value into $v0 by adding \$zero to a val

### Optimization?
- redundancy with $s0


![[Drawing 2025-09-23 08.42.44.excalidraw]]


**Start at high address to low**
**grow stack from high to low**
## Non-Leaf Procedures
- Procedures that call other procedures
	- must save $ra (return addr) register on stack at beginning of its execution
- Example:
- C code of a recursive procedure that calculates factorial
```
int fact(int n):
{
	if (n < 1) return 1;
	else return n * fact(n-1);
}
```

- MIPS code:
```
fact:
	addi $sp, $sp, -8
	sw $ra, 4($sp)         # save return addr 
	sw $a0, 0($sp)         # save arg
	slti $t0, $a0, 1       # test for n < 1
	beq $t0, $zero, L1
	addi $v0, $zero, 1     # if so, result is 1
	addi $sp, $sp, 8       # pop 2 items from stack
	jr $ra
	
L1: addi $a0, $a0, -1      # else decrement n
	jal fact  
	lw $a0, 0($sp)         # restore original n
	lw $ra, 4($sp)         # 
	addi $sp, $sp, 8
	mul $v0 $a0 $v0
	jr $ra
```
- need to save 2 registers
	- save return address register
	- save $a0 to save argument
- to call recursive fact(n-1)
	- we need to call it and pass n-1 to it
	- pass to L1 branch \$a0 and \

### Optimization?
- previously we omitted $s0 since it was redundant, but this already doesn't have $s0
- there is still redundancy
	- we saved ra but never used it nor recovered it

## Local Data on the Stack
- fp: frame pointer, a val denoting the location of the saved registers and local vars for a given procedure
- Procedure frame (activation record)
	- Used by some compilers to manage stack storage

## Memory Layout
- Text: program code
- Static data: global variables
	- e.g., static vars in C, constant arrays and strings
	- $gp initialized to addr allowing +- offsets into this segment
- Dynamic data: heap
	- e.b., malloc in C, new in Java
- Stack: automatic storage

<hr>
## Important Vocab:
- addi

### Calling Functions in MIPS Assembly
- **Call a procedure** - jump and link
	jal ProcedureLabel
	- Address of following instruction put in $ra
	- Jumps to target address
- **Return procedure**: jump register
	jr $ra
	- Copies $ra to program counter
	- Can also be used for computed jumps
		- e.g., for switch/case statements
- **Example:**

**Start at high address to low**
**grow stack from high to low