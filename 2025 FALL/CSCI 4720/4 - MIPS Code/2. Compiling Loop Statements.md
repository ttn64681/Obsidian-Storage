## Loop
- C code:
	- while (save[i] == k)  i += 1;
		- **i in $s3,** k in $s5, address of save in $s6
- Compiled MIPS code:
	- Before we can add i to the base of array save to form the address, we must multiply the index i by 4 due to the byte addressing problem. We can use shift left logical by 2 bits

```
Loop: sll $t1, $s3, 2         # multiply i by 4 (shift bits left by 2)
	add $t1, $t1, $s6
	lw $t0, 0($ t1)
	bne $t0, $s5, Exit
	addi $s3, $s3, 1
Exit: ...
```

## Flow Diagram:
![[Drawing 2025-09-18 08.12.25.excalidraw]]

## Basic Blocks
- a basic block is a sequence of instructions w/
	- no embedded branches (except at end)
	- no branch targets (except at beginning)
![[Basic Blocks Pic.png]]
	- a compiler identifies basic blocks for optimization
	- an advanced processor can accelerate execution of basic blocks

- ***Assembly uses BASIC BLOCKS to produce source code***

## More Conditional Operations
- Set result to 1 if a condition is true
	- Otherwise, set to 0
- **SET LESS THAN:** 
	- *compares val in source register w/ destination register*
```
	slt rd, rs, rt
		if (rs < rt) rd = 1; else rd = 0
```
- **SET LESS THAN IMMEDIATE:**
	- *compares val in source register w/ 16-bit signed constant (immediate val)*
```
	slti rt, rs, constant
		if (rs < constant) rt = 1; else rt = 0
```
- *Use in combination w/ beq, bne*

### Branch Instructions
- BRANCH IF EQUAL:
	- beq - 
- BRANCH IF NOT EQUAL:
	- bne

- **slt and slti are often used just before branch instructions as they allow MIPS to implement more complex conditional logic (like >, >=, <=)**

```
slt \$t0, \$s1, \$s2    **# if ($ s1 < $s2))**
bne $t0, $zero, L    # (if t0 == 0) branch to L
```

## Branch Instruction Design (Design Compromise)
- *why not blt, bge, etc?*
- **Hardware for <, ≥, ... slower than =, ≠**
	- *Combining w/ branch involves more work per instruction, requiring slower clock*
	- **All instructions penalized!!!!!**
- beq and bne are common case
- This is a good design compromise

## Signed vs Unsigned
- Signed comparison: slt, slti
- Unsigned comparison: sltu, sltui
- Ex:
![[Signed v Unsigned comparison MIPS.png]]

## Pseudo-Instructions
 - Pseudo-instructions do not correspond to real MIPS
instructions
- Instead, the assembler, would translate pseudo-
instructions to real instructions (one on more
instructions)
- Pseudo-instructions not only make it easier to
program, but also add clarity to the program, by
making the intention of the programmers clearer

## List of Useful Pseudo-Instructions
- move $to, \$t1
- li \$s0, imm
- la \$s0, addr
- lw \$to, addr
- Similar pseudo-instructions exist for sw, etc.

## Branch Pseudo-Instructions
- bge \$t0, \$s0, LABEL
	- \$at, \$t0, \$s0
	- beq \$at, \$zero, LABEL
- bgt $t0, $s0, LABEL
	- slt $at, $s0, $t0
	- bne $at, $zero, LABEL
- ble $t0, $s0, LABEL
	- slt $at, $s0, $t0
	- beq $at, $zero, LABEL
- blt $t0, $s0, LABEL
	- slt $at, $t0, $s0
	- bne $at, $zero, LABEL