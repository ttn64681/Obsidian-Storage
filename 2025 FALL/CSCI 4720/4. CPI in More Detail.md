- if diff instruction classes take diff numbers of cucles
![[Clock Cycles Detailed Formula.png]]
- Clock Cycles = total Cycles Per Instruction x IC
## Comparing Code Segments
- selecting 2 code sequences **run on the SAME CPU**
	- *same cpu means clock time is the same (constant)*
![[2 code segments CPI example.png]]
- Seq 1: IC = 5
	- 2\*1 + 1\*2 + 2\*3 = 10 total CPI
	- Avg. CPI = 10 / 5 = 2 Cycles per Instruction
- Seq 2: IC = 6
	- 9 total CPI
	- Avg. CPI = 9/6 = 1.5 Cycles per Instruction

- **people try to improve CPI or IPC (Instructions per Cycle) in order to improve performance**

## Performance Summary
**THE BIG PICTURE** - 
![[CPU Time - Big Picture.png]]
- Performance depends on
	- Algorithm: affects IC, possibly CPI
	- Programming lang: affects IC, CPI
	- Compiler: affects IC, CPI
	- Instruction set Architecture: affects IC, CPI, T_c

- *System Program written in low level because of performance*

## Energy Consumption
- The **primary source of energy consumption** in Integrated Circuit (IC) is so-called **dynamic energy** â€“ that is, *energy that is consumed when transistors switch states from 0 to 1 and vice versa*
![[Energy Consumption formula.png]]
- **Frequency switched** is a function of the clock rate.
- The **capacitive load per transistor** is a function of both the number of transistors connected to an output (called the fanout) and the technology, which determines the capacitance of both wires and transistors

## Power Trends
![[Power trends.png]]
- Clock Rate MHz  - increase then plateaus
- Power - increase then slightly decreases
- From the above figure, how could clock rates grow by a factor of 1000 while power grew by only a factor of 30? **By reducing voltage**
	- too many transistors in same area => heat problem (End of Moore's Law)

## Reducing Power Consumption
- Suppose a new CPU has
	- 85% of capacitive load of old CPU
	- 15% voltage and 15% frequency reduction
![[Power Performance Comparison Ratio.png]]
- The Power Wall
	- We can't reduce voltage further
	- We can't remove more heat
- How else can we improve performance?
	- **Multiprocessors**

## Multiprocessors
- Multicore microprocessors
	- more than one processor per chip
- Requires explicitly parallel programming
	- Compare w/ instruction level parallelism
		- Hardware executes multiple instructions at once
		- Hidden from programmer
	- Hard to do
		- Programming for performance
		- Load balancing
		- Optimizing communications and synchronization
		- Ex:
			- 2 for loops counting counter var to 100
			- run on 2 cores (parallel processing)
			- counter can be somewhere between 100-200
				3 operations/signals: read, add, write to the same memory address

## SPEC CPU Benchmark
- Programs used to measure performance
	- Supposedly typical of actual workload
- Standard Performance Evaluation Corp (SPEC)
	- Develops benchmarks for CPI, I/O, Web, ...
- SPEC CPU 2006
	- CINT2006 (integer) and CFP2006 (floating-point)
		- depends on program
	- Elapsed time to execute a selection of programs
		- Negligible I/O, so focuses on CPU performance
	- Normalize relative to reference machine
	- Summarize as geometric mean of performance ratios

![[CINT 2006 Benchmark.png]]

## Common Case Fast
- Suppose a program runs in 100 secs on a comp, w/ multiply ops responsible for 80 secs of this time
- How much do I have to improve the speed of multiplication if I want my program to run 5x faster?
![[Execution time.png]]
## Fallacy: Low Power at Idle
- look back at i7 power benchmark
	- at 100% load: 258W
	- at 50% load: 170W (66%)
	- at 10% load: 121W (47%)
- Google data center
	- mostly operates at 10% -- 50% load
	- At 100% load less than 1% of time
	- Consider designing processors to make power proportional to load
		- optimize scheduling so we can shut down many servers at data centers to reduce power consumption
		- more computers

## Pitfall: MIPS as a Performance Metric
- MIPS: Millions of Instructions Per Second
	- Doesn't account for 
		- Differences in ISAs b/w computers
		- Differences in complexity b/w instruction
- CPI varies b/w programs on given CPU
- this is why we use previous formulas to measure the performance of CPU
## Concluding Remarks
- Cost/performance is improving
	- due to underlying technology development
- Hierarchical layers of abstraction
	- In both hardware and software
- Instruction set arch
	- hardware/software interface
- Execution time: the best performance measure
- **Power is a limiting factor**
	- *Use parallelism to improve performance*

