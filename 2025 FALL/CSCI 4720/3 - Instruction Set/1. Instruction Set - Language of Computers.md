
## Instruction Set - Vocab of Commands for CPU
- Set of instructions of a computer
- *Different computers have diff instruction sets*
	- But with many aspects in common
- *Early computers have very simple instruction sets*
	- **Simplified Implementation**
- Many Modern Computers have simple Instruction sets
	- **Reduced Instruction Set Computers (RISC)**
		- single operation in one instruction
			- Ex: ARM (Advanced RISC Machine - mobile device architecture)
	- **Complex Instruction Set Computers (CISC)**
		- multiple operations in one instruction

## MIPS Assembly
- specific family of RISC instruction set architectures
- There is Assembly language FOR MIPS
## Assembly Arithmetic Operations
- **Add and Subtract, 3 operands**
	- *2* **Source Operands**
	- *1* **Destination Operand**
		- *ADD a, b, c //* a gets b + c
- All arithmetic operations have this form

- **Design principle 1:** Simplicity favors regularity
	- Regularity makes implementation simpler
	- Simplicity enables higher performance at lower cost

### Assembly Arithmetic Ex:
- **C code:**
	- f = (g+h) - (i + j)
- **Compiled LEGv8** (a subset of ARM) code
	- ADD t0, g, h     *// t0 = g + h*
	- ADD t1, i, j        *// t1 = i + j*
	- SUB f, t0, t1     *// f = t0 - t1*
## Register Operands
- Arithmetic instructions use **register operands**
- **MIPS has a 32 x 32-bit register file**
- **Use for frequently accessed data**
	- *Numbered 0 to 31*
- **32-bit data called a "word"**
- *Assembler names for register*
	- $t0, $t1, ..., $t9 for temporary values
	- $s0, $s1, ..., $s7 for saved variables

- **Design Principle 2: Smaller is faster**

- *We don't talk about cache b/c it is invisible in software layer*
- **Register is visible in software layer**
## MIPS Registers

| register | assembly name | Comment |
| -------- | ------------- | ------- |
| r0       |               |         |
| r1       |               |         |
| r2-r3    |               |         |
| r4-r7    |               |         |
| r8-r15   | $t0 - $t7     |         |
| r16-r23  | $s0 - $s7     |         |
| r24-r25  | $s0 - $s7     |         |
| r26-r27  |               |         |
| r28      |               |         |
| r29      |               |         |
| r30      |               |         |
| r31      |               |         |

## Register Operand Ex:
- C code:
	- f = (g + h) - (i + j);
	- f, ..., j in $s0 to $s4
		- *f to j is stored in s0 thru s4* **??????????????????**
- Compiled MIPS code:
	- add $t0, $s1, $s2     # $t0 <- g + h
	- add $t1, $s3, $s4     # $t0 <- i + j
	- sub $s0, $t0, $t1     # $s0 <-  $t0 - $t1


## MIPS arithmetic Instructions
- Each performs one operation
- destination <- source1 **op** source 2
- add $t0, $s1, $s2
		|
		-> Destination
- sub $s1, $s2, $s3
- addi $s1, $s2, 20


## Immediate Operands
- Constant data specified in an instruction
- For example, for addition immediate instruction
	- addi $s2, $s3, **4**
		- **4 is the immediate op**

- This avoids a load instruction from memory, making operations w/ small constants faster (*"Make the common case fast")*

- There is no subtract immediate instruction, but
	- Just use a negative constant
		- addi $s2, $s1, -1

- **Design Principle 3: Make the common case fast**
	- Small constants are common
	- Immediate operand avoids a load instruction

## The Constant Zero
- MIPS register 0 ($zero) is the constant 0
	- cannot be overwritten
- Useful for common operations
	- E.g., move b/w registers
		- add $t2, $s1, $zero

## Unsigned Binary Integers
- Given an n-bit number
$$ x = x_(n-1) \ 2^(n-1) + x_(n-2) \ 2^(n-2) + ... + x_1 2^1 + x_0 2^0 $$
- **Range: 0 to +2^n - 1**
	- **If n = 4,** *Range:  0000 to 1111* **(15 in decimal)**

- Most Significant Bit (leftmost) = Signed bit

- Example (32 bits)
	- 0000 0000 0000 0000 0000 0000 0000 1011_2
	- = 0 + ... + 1x2^3 + 0x2^2 + 1x2^1 + 1x2^0
	- = 0 + ... + 8 + 0 + 2 + 1 = 11_10
- Using 32 bits
	- 0 to +4,294,967,295

## 2s-Complement Signed Integers
- Given an n-bit number
- If we have 4 bits to represent a signed binary number,
	- the minimum val = -8
		- **1**000
	- the maximum val = 7
		- **0**111

### LIMITS for Unsigned vs Signed: Max 4-bit Val 
For a 4-bit number:
1. **Unsigned Integers:**
    - **Minimum Value:** `0000_2` = **0**
    - **Maximum Value:** `1111_2` = **15**
2. **2's Complement Signed Integers:**
    - **Minimum Value:** `1000_2` = **-8**
    - **Maximum Value:** `0111_2` = **+7**

- *For 4-bit number, cannot convert 1111 (15)*
	- *Max val you can convert is 0111 (7)*

## 2s-Complement
- System to represent signed integers
- **2 purposes:**
1. *Find negative of a number*
2. *Perform subtraction*
**Steps:**
	- flip bits
	- add 1

## Signed Negation
- Complement and add 1
	- Complement means 1 -> 0, 0 -> 1

- Ex: negate +2
	- +2 = 0000 0000 ... 0010_2
	- -2 = 1111 1111 ... 1101 + 1
	-       = 1111 1111 ... 1110_2

## Sign Extension
- **Representing a number using more bits**
	- **Preserve the numeric value**
- **In MIPS instruction set**
	- addi: extend immediate value
	- 1b, 1h: extend loaded byte/halfword
	- beq, bne: extend the displacement
- **Replicate the sign bit to the left**
	- c.f. unsigned values: extend with 0s

- **Ex: 8-bit to 16-bit**
	- +2: 0000 0010 => 0000 0000 0000 0010
	- -2: 1111 1110 => 1111 1111 1111 1110
		- *(to find positive equivalent, do 2s complement)*


## Memory Operands
For CPU view of memory (RAM):
- **Memory is a linear array of bytes**
- **each element is a byte**
(*Actual implementation of memory is quite different*)

- **When CPU provides data, it must provide address of data (index location), and each address corresponds to a value (byte)**
	- *Ex: CPU wants to read*
		- places address on address bus, and
		- memory system responds by putting data found at address onto data bus for CPU to read
	- *Ex: CPU wants to write*
		- places both address and data on address bus and data bus and signals memory to store it (control bus)

- **Main memory used for composite data**
	- Arrays, structures, dynamic data
- **To apply arithmetic ops**
	- Load vals from memory into registers
	- Store results from registers to memory
- **Memory is byte addressed**
	- Each address identifies an 8-bit byte
	- Word-aligned address must be a multiple of 4

## MIPS is Big Endian
![[MIPS is Big Endian.png]]
## Memory Address and Contents
- To access word in memory, instruction must supply memory address
![[Memory addr ez.png]]
- The address of 3rd data element is 2 and the value of Memory [2] is 10

## Data Transfer Instructions Load and Store
- Load: transfer from memory to register
- Store: transfer from register to memory

- Load one word from memory: lw $s1, 20 (\$s2)
	- which means $s1 = Memory[$ s2 + 20]
	- THe memory address -- a 32-bit address -- is formed by adding contents of the base address register ($s2) to the offset value (20)
- Store a word: sw $s1, 20($ s2)
	- Which means: Memory[$s2 + 20] = $s1