- Instructions are encoded in binary
	- Called machine code
- MIPS instructions
	- Encoded as 32-bit instruction words
	- Small number of formats encoding operation code (opcode), register numbers, ...
	- Regularity!
- Register numbers 
	- $t0-\$ t7 are reg's 8-15
	- $t8-\$ t9 are reg's 24-15
	- $s0-\$ s7 are reg's 16-23


## MIPS R-Format Instructions
- **Register Format Instructions**
- For register to register arithmetic and logical operations,
	- using funct to specify the exact operation

| op     | rs     | rt     | rd     | shamt  | funct  |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 6 bits | 5 bits | 5 bits | 5 bits | 5 bits | 6 bits |
- Instruction fields
	- op: operation code (opcode)
	- rs: first source register number
	- rt: second source register number
	- rd: destination register number
	- shamt: shift amount (00000 for now)
	- funct: function code (extends opcode)

## R-Format Example

| op     | rs     | rt     | rd     | shamt  | funct  |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 6 bits | 5 bits | 5 bits | 5 bits | 5 bits | 6 bits |
add $t0, \$s1, \$s2

| special | $s1 | $s2 | $t  | 0   | add |
| ------- | --- | --- | --- | --- | --- |

| 0   | 17  | 18  | 8   | 0   | 32  |
| --- | --- | --- | --- | --- | --- |

| 000000 | 10001 | 10010 | 01000 | 00000 | 100000 |
| ------ | ----- | ----- | ----- | ----- | ------ |
0000001000100100000000100000_2 = 02324020_16 (hex)


## Hexadecimal
- Base 16
	- Compact representation of bit strings 
	- 4 bits per hex digit

| 0   | 0000 | 4   | 0100 | 8   | 1000 | c   | 1100 |
| --- | ---- | --- | ---- | --- | ---- | --- | ---- |
| 1   | 0001 | 5   | 0101 | 9   | 1001 | d   | 1101 |
| 2   | 0010 | 6   | 0110 | a   | 1010 | e   | 1110 |
| 3   | 0011 | 7   | 0111 | b   | 1011 | f   | 1111 |
- Ex: eca8 6420
	- 1110 1100 1010 1000 0110 0100 0010 0000



## MIPS I-Format Instructions
- **Immediate Format Instructions**
- For operations involving immediate values like addi or memory access like lw,
	- using the 16-bit field for the constant or address offset

| op     | rs     | rt     | constant or address |
| ------ | ------ | ------ | ------------------- |
| 6 bits | 5 bits | 5 bits | 16 bits             |
- Immediate arithmetic and load/store instructions
	- rt: destination or source register number
	- Constant: -2^15 to +2^15 -1
	- Address: offset added to base address in rs
	- addi $s1, $s2, 20

- **Design Principle 4: Good design demands good compromises**
	- Different formats complicate decoding, but allow 32-bit instructions uniformly
	- Keep formats as similar as possible

## Stored-Program Computers
- Instructions represented in binary, just like data
- Instructions and data stored in mem
- Programs can operate on programs
	- e.g., compilers, linkers, ...
-  Binary compatibility allows compiled programs to work on different computers
	- Standardized ISAs


## Logical operations
- Instructions for bitwise manipulation
![[Logical Operations for bitwise in MIPS.png]]

- Useful for extracting and inserting groups of bits in a word

## Shift Operations

| op     | rs     | rt     | rd     | shamt  | funct  |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 6 bits | 5 bits | 5 bits | 5 bits | 5 bits | 6 bits |
- shamt: how many positions to shift
- Shift left logical
	- Shift left and fill w/ 0 bits
	- sll by i bits multiplies by 2^i
- Shift right logical
	- Shift right and fill w/ 0 bits
	- srl by i bits divides by 2^i (unsigned only)


## Shift Left and Right Logical Examples
- sll $t1, \$s3, 2    # result: Temp reg $t1 = i * 4 = (\$s1)
- srl $t1, \$s2, 2    # \$s1 = \$s2 >> 2 shift right by constant


## AND Operations
- Useful to mask bits in a word
	- Select some bits, clear others to 0
	and $t0, $t1, $t2
![[AND ops in MIPS.png]]

## OR Operations
- Useful to include bits in a word
	- Set some bits to 1, leave others unchanged
	or $t0, $t1, $t2
![[OR Operations in MIPS.png]]


## NOT Operations
- Useful to invert bits in a word
	- Change 0 to 1, and 1 to 0
- MIPS has NOR 3-operand instruction
	- a NOR b == NOT (a OR b)
	nor $t0, \$t1, \$zero          <-- Reg 0: always read as 0
![[NOT Operations in MIPS.png]]

## Conditional Operations
- Branch to a labeled instruction if a condition is true
	- Otherwise, continue sequentially
- beq rs, rt, L1
	- if (rs == rt) branch to instruction labeled L1;
- bne rs, rt, L1
	- bne $s3, \$s4, Else
	- if (rs != rt) branch to instruction labeled L1;
- j L1
	- Unconditional jump to instruction labeledd L1

Branch instructions
![[Branch Instructions.png]]

## Compiling If Statements
- C Code:
`if (i == j) f = g+h;
`else f = g-h
- Compiled MIPS code:
`bne $s3, $s4, Else `
	`add $s0, $s1, $s2`
	`j Exit`
`Else: sub $s0, $s1, $S2   # Assembler Calculates Addresses
`Exit: ...`

## MIPS Assembly Syntax

| .data                    | # This is a data section                    |
| ------------------------ | ------------------------------------------- |
| hello:                   | # This is the label of the following string |
| .asciiiz "Hello World\n" | # A string in the data section              |
| .text                    | #                                           |
|                          |                                             |

## MIPS Simulators
- SPIM: A MIPS32 Simulator
	- you can install compatible version of QtSpim on your computer
- Online MIPS simulators
	- WeMips
	- CPUlator
	- JsSpim
- Other MIPS simulators
	- QtMips
	- EduMIPS64