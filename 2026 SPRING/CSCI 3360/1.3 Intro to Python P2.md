```table-of-contents
```
# Last Time...
## Tuple
- immutable list

- type((1)) # <class 'int'>
- type((1,)) # <class 'tuple'>
- type(()) # <class 'tuple'>

- a,b,c = (1,2,3)
- d,e,f = 4,5,6
- e,d - d,e

<hr>
# Continuing Python

## Dictionary { key:val }
- unordered
- Mappings from keys to values
- key must be immutable
	- tuple: valid_dict = {(1,2,3 ) : [1,2,3]}
	- string: filled_dict = {"one":1, "two":2, "three":3}

### getting keys
`list(filled_dict.keys())`
- returns Iterator

### getting values
`list(filled_dict.values())`

### get() value by key
`filled_dict.get('one')`
- *second param is default value if key not found*

### set default key:value by get()
`filled_dict.get('four', 4)`
- *second param is default value if key not found*
### setdefault() key:value
`filled_dict.setdefault("five", 5)

### update() key:value
`filled_dict.update( {"four":4} )`
- provide the key-val dict pair as param

### update key:value by assignment
`filled_dict["four"] = 4`

### pop() pair by key
`filled_dict.pop("five")`
- returns the val

### popitem() last inserted item
`filled_dict.popitem()`

### del key:val by key
`del filled_dict["one"]`

### clear() dict
`filled_dict.clear()`
``
### membership (only for keys)
- can only check membership of keys
`'one' in filled_dict # => True`


## Set set(), { val }
- ordered, unique (no duplicates)
- immutable items only
	- `invalid_set = {[1], 1} # =? Raises TypeError: unhashable type: 'list'`
	- `valid_set = {{1,), 1}`

### add()

### set operators

	filled_set & other_set # => {3,4,5}

	filled_set | other_set # => {1,2,3,4,5,6}

	\- returns set difference

	^ returns set symmetry-difference (non-overlapping)
		- venn diagram w/o the middle

	\>= returns check is right is subset of set on left

	<= returns check is left is subset of set on right


## Control Flow
### if/elif/else

### match/case
- like switch case

```
command = "run"
match command:
	case "run":
		print()
	case "speak" | "say hi":
		print()
	case code if command.isdigit():
		print(f"The robot execute code: {code}")
	case _: # default/else
		print("Invalid")
```

### loop: for
- can iterate over any iterable, including strings, lists, tuples, dicts, and via enumerate()
`for x in y
```
for i,val in enumerate(animals)
	print(i, value)
0 dog
1 cat
2 mouse
```
```
for i in range(4):
	print(i)
0
1
2
3
```

### loop: while

<hr>

# Function

```
def add(x,y):
	# something...
	
add(5,4)
add(y=4,x=5)
```

## \*args, \*\*kwargs
- allows a function to accept an abritrary (variable) number of args w/o having to define them explicitly in func signature
	- \*args (abritrary positional args)
		- allows func to accept 0+ non-keyword (positional) args
	- kwargs is keyword args
		- allows a func to accept 0+ keyword args (args passed with a `key=value` syntax).
```
def all_the_args(*args, **kwargs):
	pring(args)
	print(kwargs)
	print()

args = (1,2,3,4)
kwargs = {"a":3, "b":4}

all_the_args(*args) # equivalent: all_the_args(1,2,3,4)

all_the_args(**kwargs) # equivalent: all_the_args(a=3, b=4)

all_the_args(*args, **kwargs)


############ OUTPUT ############
(1,2,3,4)
{}

()
{'a':3,'b':4}

(1,2,3,4)
{'a':3,'b':4}

```


## Scope
- python is function scoped
```
x = 5

def set_x(num):

def set_global_x(num):
	global x
	print(x) # => 5
	x = num
	print(x) # => 96

set_x(43)
set_global_x(96)
print(x) # => 96
```

## lambda functions
- def compare(lambda x: x>5, y)

### map and filter
- map: 
	- returns list given func
- filter:
	- returns list of items passing comparator
- list(map(max, [1,2,3], [4,2,1])) # => [4,2,3]
- list(filter(lambda x: x>5, [3,4,5,6,7])) # => [6,7]

### list comprehension
- similar to lambda func w/ map and filter
- x will return the result of the expression to right

```
[x for x in [3,4,5,6,7] if x>5] # => 

{x for x in "abcddeef" if x not in "abc"} # => {'d', 'e', 'f'}

{x: x**2 for x in range(5)} #=> {0:0, 1:2, 2:4, 3:6, 4:8}
```

## zip (combine lists' items into tuples)
```
names = ['apple', 'banana']
prices = [2,5]
for name, price in zip(names, prices):
	print(name, price)
```

`list(zip(names,prices))
	- `[('apple', 2), ('banana', 5)]

- zip can be used for creating dictionaries
`dict = zip(names, prices)`
- `{'apple': 4, 'banana': 5}
# Error Handling
## try-except  
- BAD:
```
try:
	print("this gets executed first")
	x = 1/0 # ZeroDivisionError
except:
	print("something bad happened!")
```

- BETTER:
	- specific error checking
```
x = [5,9]
try:
	print(x[4])
except IndexError as e:
	print('Warning! Index out of bound!')
except (TypeError, NameError):
	pass
else:
	print("All good!")
finally:
	print("We canc lean up resources here")
```








<hr>
# Notes

- type(x)
- f"{len(x)}"
- li2 = li[:]

- shallow copy vs deep copy
	- both are new objects, but **shallow** keep same pointers to og
	- **deep** copy has new pointers/references

- 