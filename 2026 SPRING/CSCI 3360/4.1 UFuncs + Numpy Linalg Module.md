```table-of-contents
```
# Intro
- Python is an interpreted language
- has override operations to determine the types on-the-go

# UFuncs
- looping over millions of elements is slow
- UFuncs (Universal Functions) allow for vectorized operations on arrays, significantly faster than Python's native loops for large datasets.

## Arithmetic UFuncs
- Numpy wraps standard Python math operators  

```python
import numpy as np
x = np.array([0, 1, 2, 3]) # Initialize x as a NumPy array
y = x + 5 # Addition
z = x _2 # Multiplication
print(f"x: {x}")
print(f"x + 5: {y}")
print(f"x_ 2: {z}")
```

- Common arithmetic ufuncs include `np.add`, `np.subtract`, `np.multiply`, `np.divide`, `np.power`, `np.mod`

## Loop speed
```
import numpy as np
rng = np.random.default_rng(seed=2196)

def compute_reciprocals(values):
	output = np.empty(len(values))
	for i in range(len(values)):
		output[i] = 1.0 / values[i]
		
	return output
```

- can  `%timeit

## Aggregations
- Computes summary statistics from a large dataset
	- ex: includes `sum`, `min`, `max`, `mean`, `median`, `std` (standard deviation).
- The axis argument specifies the dimension the aggregation is performed, effectively "collapsing" that dimension
	- axis = 0: "Compute the rows"
		(Compute column statistics)
	- axis = 1: "Collapse the columns"
		()Compute row statistics)

## sum,min,max
- Python has built-in
	- sum, min, max
	- sum(x,2)
		initializes sum. to 2
	- np.sum(x,2)
		sums along axis 2

# Broadcasting
- a set of rules for applying binary UFuncs on arrays of diff sizes
- Ex:
	- Adding a scalar to an array (arr + 5)
	- The 5 is "broadcast" (stretched) to match the array shape.

## Broadcasting Rules
1. If 2 arrays differ in their # of dimensions, the shape of the one w/ fewer dimensions is PADDED w/ ones on its leading (left) side
2. If the shape of 2 arrays DON'T MATCH in any dimension, the array w/ shape equal to 1 in that dimension is stretched to match the other shape
3. If in any dimension the sizes disagree and neither is equal to 1, anerror is raised

## Ex 1: 
```python
  M = np.ones((2,3))
  a = np,arange(3)
```
- M.shape is (2,3)
- a.shape is (3)

1. whichever shape is smaller in dimensions, but a leading 1 (left)
	1. a = np.arange(1,3)

2. then copy those values and stretch it across the dimension its lacking in

## Ex 2: 
```python
  M = np.ones((3,2))
  a = np,arange(3)
```
- cannot be done
- dimension mismatch (needs a 1 in one of M's axis)

# Boolean Masks
- Using comparison ops (<, >, \==) on arrays returns a bool array

# Linear Algebra submodule
- numpy.linalg, numpy.matrix
	- linalg contains SVD
	- Dot Product: np.dot(a,b) or a@b (Python 3.5+)
	- Transpose: A.T swaps rows and cols
	- Inverse: A.I
	- eigenvalues and eigenvectors: la, v = linalf.eig(A)