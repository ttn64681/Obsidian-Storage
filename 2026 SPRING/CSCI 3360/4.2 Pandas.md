```table-of-contents
```
# Intro
- a package built on top of NumPy
- Efficient Implementation of DataFrame
	- MultiDimensional Arrays w/ row and col labels
	- Handles heterogeneous types and missing data
- Essential fro data munging and preparation
- can visualize data, but SciKit Learn/ SkiPy/ etc. are better

- Pandas has diff types of objects:

# 1. Series Object
- 1D array of indexed data
- Created from list or array
- contains both sequence of values and sequence of indices
- Attributes:
	- Access raw data: 
		- .values
	- Access index object: 
		- .index
		- returns RangeIndex(start=0, stop=4, step=1)

## Series vs NumPy Array
- NumPy arrays: **Implicit integer index**
- Pandas Series: *explicit defined index*
- <span style="background:#fff88f">Index can be values of any type</span>
	- (integers, strings)
- Indices do NOT need to be sequential!
```python
data = pd.Series([0.25, 0.5, 0.75, 1.0], index=[2,'5',3,7])
data

2    0.25
5    0.50
3    0.75
7    1.00
dtype: float64
```

## Series as Specialized Dicts!
- We can use Series as Dictionaries w/ diff key types
	- Maps arbitrary keys to a set of typed vals
- Type information makes it more efficient than Python dicts
- Can be constructed directly from a Python dict

# 2. Dataframe Object
- Generalized 2D-array
- Sequence of aligned Series objects
- Has both row indices and column names
- Attributes:
	- Access row labels: .index
		- 
	- Access column labels: .columns
		- 

## Ex: Converting file -read_\*-> DataFrameObject -to_\*-> file
![[Drawing 2026-02-03 13.32.28.excalidraw]]

```python
population = {'Georgia': 10736000, 'Florida': 21540000, 'Texas': 29180000, 'California': 39250000}

area = {'Georgia': 59425, 'Florida': 65758, 'Texas': 268596, 'California': 163695}

states = pd.DataFrame({'population': population, 'area': area})
states

            population    area
Georgia     10736000   59425
Florida     21540000   65758
Texas       29180000  268596
California  39250000  163695
```

- Can be constructed from:
	- A single series
	- A list of dicts
	- A dict of series
	- A 2D NumPy array

# 3. Index Object
- Functions as an **immutable array** and an **ordered set**
	- Prevents side effects when sharing indices b/w DataFrames
	- Standard indexing syntax works, but assignment fails
- Used to reference and modify data
- Constructed explicitly or implicitly
```python
python
print(data.index)
print(states.index)
print(states.columns)

Index([2, '5', 3, 7], dtype='object')
Index(['Georgia', 'Florida', 'Texas', 'California'], dtype='object')
Index(['population', 'area'], dtype='object')
```
## Index as Ordered Set
- Index object follows many of the conventions used by Python's built-in set data structure

# Operating on Data - UFuncs
- Pandas works w/ NumPy's universal functions (UFuncs)
- Index preservation:
	- Result retains the original index labels

## Index Alignment in Series

## Index Alignment in DataFrames

## Data Selection in Series
- Dictionary-like
	- Check presence of keys:
		- 'a' in data
	- Access values via keys:
		- data['b']
	- List keys: data.keys()
- Array-like
	- Slicing w/ explicit index:
		- data['a':'c']
			- Explicit slices include the final element
	- Masking:
		- data[(data > 0.3) & (data < 0.6)]
	- Fancy indexing:
		- data [\[ 'a',' e'\]]

## Data Selection in DataFrames
- Accessing Cols
	- Dictionary style access (recommended)
		- data['area']
		- data[\['area', 'population'']]
	- Attribute style access
		- data.area
		- Avoid if column name conflicts w/ DataFrame methods (e.g., *pop*, *count*)
- Accessing Rows
	- Slicing w/ explicit index does not work
	- Filtering based on col val can work:
		- data['area' > 20000]
	- Indexing based operations: loc, iloc

- Why indexing w/ explicit index is ambiguous?
```python
data = pd.DataFrame([[i, i**2] for i in range(3)])
data
```
```python
data[1]

0  0
1  1
2  4
```

## .loc
- Primarily label based
- Allowed inputs:
	- A single label
	- A list or array of labels
	- A slice object w/ labels
	- A Bool array
	- A tuple of row (and col) indices
```python
  a b c
--------
0 0 0 0
1 1 2 1
2 2 4 4
3 3 6 9
4 4 8 16


data.loc[[0,2]]
0 0 0 0
2 2 4 4

data.loc[2:5]
2 2 4 4
3 3 6 9
4 4 8 16

data.loc[[True,False,True,True,False]]
```

## .iloc
- Primarily integer position based
- Allowed inputs:
	- An integer
	- A list or array of integers
	- A Boolean array
	- A tuple of row (and col) indices

## .loc vs .iloc
- **`.loc`**: Label-based indexing. You refer to rows and columns by their actual labels (names). Slices are **inclusive** of the end label.
- **`.iloc`**: Integer-position-based indexing. You refer to rows and columns by their 0-based integer positions. Slices are **exclusive** of the end position.


# Review
- When selecting subsets of data, square brackets are used
- Inside these square brackets, you can use 
	- single col/row label
	- list of col/row labels
	- a slice of labels
	- a conditional expression or
	- a colon
- Use loc for label-based selection (using row/col names).
- Use iloc for position-based selection (using table positions).
- You can assign new vals to a selection based on loc/iloc

