- extend Node.js w 3rd party packages
- Define package dependency

- Node framework provides limited set of feats for building web apps
- For example, node doesn't provide parsing function for XML messages

- Send an HTTP request to get data
- manual parsing must happen

Disadvantages of manual parsing:
- string matching ignores the structure of XML data
- The message body might contain malformed XML data
- string matching could be more efficient than building an XML tree of the data
- string matching is less tolerant to changes in XML data structure
- if message adds or removes any XML elements, you must change regular expression on string match function

Parse XML elements to JS
- the xml2js Node.js pkg parses a string of XML elements into JS object
- unlike other xml parsing node packages, xml2js uses only JS
- 3rd party packages might have a diff software license than Node.js framework

install via npm install 
import pkg

let parseString = require('xml2js').parseString;

# Introduction to Web Frameworks
- differentiate b/w Node.js and Node.js based web frameworks
- Explain MVC and REST API **arch styles**
- Describe prominent feats of several node web frameworks

Runtime Environments:
- Node is NOT a web framework
- it is a runtime env that runs JS on a server
- runs on V8 engine, a JIT compiler (interpreter)
- Runtime envs are the hardware and software that can execute progs w/ a particular codebase

Node framework:
- the skeletons on which an app is built
- Node.js requires a web framework to utilize it
- Node.js frameworks are called node frameworks
- Node frameworks are used in conjunction with node to support the application
- **2 approaches to building backends that web frameworks can employ:**
	- Model-View-Controller
	- Representational State Transfer Application Programming Interface
### MVC vs. REST API: Key Differences and Relationship
- Both arch styles
(They are not mutually exclusive)

**Model:**
- is an **architectural _pattern_** for **structuring an application's internal code**. 
- provides a blueprint for organizing an app into 3 interconnected logical components
- Scope: Focuses on internal structure of application or specific app layer
![[Pasted image 20250720020344.png]]
- Model: 
	- manages app data, interacts w/ database and handles data logic (business logic, and rules)
- View:
	- displays data and handling UI
- Controller:
	- Regulates data flow, Processes data provided by user
	- intermediary layer, handling user Input, updating Model, and selecting appropriate View to display

REST API:
- arch style for designing networked applications
- to enable standardized and scalable communication
- Scope: focuses on external communication protocol and style b/w distributed systems

| Feature    | MVC (Model-View-Controller)                                | REST API (Representational State Transfer API)                    |
| ---------- | ---------------------------------------------------------- | ----------------------------------------------------------------- |
| **Type**   | Architectural **pattern** for SINGLE application structure | Architectural **style** for networked applications communication  |
| **Scope**  | How an application's internal components interact          | How client and server components communicate over HTTP            |
| **Output** | Often generates full UI (e.g., HTML pages) for the user    | Primarily sends/receives data (e.g., JSON, XML) to/from clients   |
| **Focus**  | Separation of concerns for logic, data, and presentation   | Uniform interface for resource-oriented communication (stateless) |
| **Layer**  | Often considered the _application layer_ structure         | Defines the _communication layer_ between distributed systems     |
MVC Arch Pattern
- This is a **conceptual blueprint, a set of guidelines, or a recommended way to organize the code** in your application.
### Popular frameworks that can implement MVC:
#####  - used for apps that need separation of data, from data presentation, and from the manipulation of data
- examples:
	- **Django** (more so MVT Model-View-Template)
	- **Koa**
	- **Express.js**
	- **NestJS**
	- Laravel, Symfony, CodelIgniter (PHP)
	- Spring MVC (Java)
	- ASP.NET Core MVC

Crucially, MVC is an arch pattern, not arch style, so it **concerns within the same single application or single layer to separate concerns**. It typically resides w/in the Application Tier and sometimes partially the Presentation Tier of a 3-tier architecture, for example.
- An Arch Style could encompass MVC, like microservices or P2P

### REST APIs
- allow multiple web services to communicate with each other and client
- RESTful APIS:
	- Client and server code are independent of each other
	- client does not know state of server and vice versa (stateless)
		- each client request is self-contained (includes all data, auth credentials, and session info, and context that the server needs)
		- no server-side memory of past requests: server forgets immediately
			- Analogy: your request is the ticket, and server only has to check your ticket. doesn't need to look up extra info from database
	- communicate via ops on resources
	- communication does not rely on an implementation of the API

Data transfer w/ RESTful API:
- client requests resources using REST API using HTTP methods
- server responds w representation of the state of the resource to client
- the representation of data transferred is usually JSON payload (or HTML, Python, PHP, plain text, XLT *(this might be inaccurate, AI says this is not true*)

Popular Frameworks on these Backend Structures:
#### Express:
- used primarily for routing and middleware
- easy to implement an MVC arch pattern
- provides debugging mechanisms
- Advantages:
	- handles mult ops concurrently
	- has HTTP helpers for handling HTTP requests
	- Helps facilitate comms between client-server
	- efficiently provides HTTP headers to URLS to get needed data requested by client

#### Koa:
- designed by same team that designed Express
- Smaller, more expressive, more robust foundation for web apps and APIs
- uses async funcs such that callbacks are not necessary
- Increased error-handling ability
- Advantages:
	- appropriate for apps that are high-performing, demanding, complex, and developed by large-dev team

#### Socket.io:
- Best for apps w/ real-time bidirectional data exchange b/w clients and servers
- Utilizes WebSocket rather than HTTP for comms
- servers push data w/o request from client
- Advantages:
	- works well with apps such as chat rooms
	- texting
	- video conferencing
	- multi player games

#### Hapi.js:
- Open-source
- Lots of built-in security
- Many built-in plugins so no need for unofficial middleware
- Good for developing:
	- Proxy servers
	- API servers
	- HTTP proxy apps
	- REST APIs

Nest.js:
- appropriate for dynamic, scalable, enterprise apps
- Flexible
- multitude of libraries
- easy to implement an MVC arch
- Built on top of Express
- Compatible w/ Type Script
- Works in conjunction w/ Angular
- Combines object-oriented and functional reactive programming
	- this potentially doubles productivity and application performance

# Express Web Application Framework
primary uses of Express

### App framework for Node.js
- Express is a 3rd-party module that provides a framework for building web apps
- one of most popular

#### 2 Purposes
- as an API
- Setup templates w/ server-side rendering

#### APIs w/ Express
- An Express API sets up an HTTP interface to interact w/ data layer of the app
- Data is sent back to client in JSON using response, or res, object
- res.json() method:
	- notifies client of the content type being sent
	- can be used to stringify data (convert js to json format)

#### SSR w/ Express
- SSR is used to create templates
	- templates are separate files used to allow for dynamic data to be passed in
- Data is sent from client to server
- Templates use that data to create HTML, CSS, JS
	- This is accomplished using the **res.render()** method
		- tells Express to locate template file (set up via app.set('views', ...))
		- process template engine
		- generate html string
		- send html as http response

### Main Differences Summarized:

|Feature|Express as Pure API Backend|Express for Server-Side Rendering (SSR)|
|---|---|---|
|**Primary Output**|JSON data, minimal `index.html` shell, static assets|Full HTML pages|
|**HTML Generation**|Client-side (by React/Vue/Angular JS in browser)|Server-side (by Express + Template Engine)|
|**View Engine**|Not used for content pages (might serve static HTML)|Essential (`app.set('view engine', 'ejs')`)|
|**Client-Side JS**|Handles all UI rendering, routing, data fetching|Mostly for interactivity _after_ initial HTML render|
|**Architecture**|Decoupled Frontend/Backend (SPA)|Traditional Full-Stack (MPA)|


<hr>

### Application framework for Node.js
**Express:**
- Express implements an app class that you map to a web resource path
	const app = express()
		`app.get('/about', (req, res) => { [code] })`
		**- in this way, you map about url path directly to a function**
**Node:**
- In contrast, the standard Node.js framework treats HTTP requests at a lower network level
	- when using Node.js core API, the http.createServer() relies on custom callback func to parse through web resource path
		`if (request.url === '/about') { ... } else if (request.url === '/contact') { ... }` etc...

How Express works
1. DECLARE: declare express as dependency in pkg manifest of node.js project
2. INSTALL: run npm command to donwload any missing modules
3. REQUIRE: import express module and create express app
4. CREATE: create new route handler
5. START: start HTTP server on given port num
- 
1. DECLARE AS DEPENDENCY
- create package.json file in proj folder
- stores name, version, description, main, and dependencies
	- Name: name for Node.js module
	- Version: string defines major and minor version number of module
	- Description: describes purpose of module
	- Main: Identifies Node.js script as entry point into module
	- Dependencies: Lists which node.js modules the current module requires
![[Pasted image 20250722005001.png]]

2. RUN NPM TO DOWNLOAD
`npm install <module>`

# My First Express Web App
mynodeserver.js -
![[Pasted image 20250722005433.png]]
- import module
- create instance of app object from express framework
- to handle web app requests, map HTTP method and web resource path to JS function
	- app.get - listens to incoming HTTP GET requests that request to /temperature resource path
	- Run the weather.current function with a location param taken from the resource path 
- Start HTTP server on port via web server object (instance) 


# Insider viewpoint:
- Express allows for high level expressive declaration of REST API endpoints -> readability
- offers great middleware
- very fast and easy for dev cycle
- abstracts low-level code making it more efficient for devs
- some use fully managed services rather than Express
	- then they let API gateway service handle API requests for you and wrote code to respond

# Intro to Middleware & Routers

Middleware:
- **Middleware is software that sits between applications, databases, or services and allows those different technologies to communicate.**
	- It creates seamless interactions for the end user in a distributed system.
- Express is a messaging framework used to **handle routes** and **write middleware.**
- ***Front-end can't communicate directly with back-end***, so needs middleware
- **A web server is an example of middleware that connects a website to a database.** The web server handles the business logic and routes the data from the database based on the request.

Routes:
- A _route_ is the part of the code that associates an HTTP request, such as GET, POST, or DELETE, with a URL and the function that gets called that handles that URL.
- Routing is used in web development to split an application’s user interface based on rules identified by the browser’s URL.

***Router functions are called “middleware” collectively. 
Middleware is responsible for responding to an HTTP request or calling another function in the middleware chain.***

- Express handles router functions through the Router class, such as Router.get(). 
	- As the name suggests, Router.get() handles HTTP GET requests.  
- Other Router functions include Router.post(), Router.put(), Router.delete() in mostly the same way. 
- These methods take two arguments, a URL path and a callback function.

- In addition to routing, middleware is also responsible for providing secure connections among services by encrypting and decrypting data, managing application loads by distributing traffic to different servers, and sorting or filtering data before the data is returned to the client.

# Routing, Middleware, and Templating
- explain routing
- describe middleware
- explain template

# Routing
- Requests to different routes
- GET POST PUT DELETE
	- server must handle each request to each route,
	- OR return appropriate error message (status: 200, message: " ")
- Routing can be handled at app level or at router level

### Routing at app level
![[Pasted image 20250722011735.png]]
### Routing with routers
- handle diff routes and requests
![[Pasted image 20250722011915.png]]
- specific userRouter and itemRouter

### Middleware
- functions that have access to the request and response objects and the next function
- express app can have more than 1 middleware, and they can be chained to each other
- categorized based on purpose, use, and source
	1. app level
	2. router level
	3. error handling
	4. built in
	5. third party
- good for parsing requests, authentication, and handling errors

examples: 
- express.json(): Middleware to check and parse JSON bodies
- express.static(): Middleware to check if request is for a static file
#### App-level middleware
- bound w/ app.use()
![[Pasted image 20250722012556.png]]
- routing useful for activities like auth and checking session info
- gatekeeper, no request to app server can go past it

#### Router-level middleware
- bound w/ router.use()
[ itemRouter userRouter  example]
![[Pasted image 20250722012809.png]]

- you can use router-level middleware in separate router file, then module.exports = userRouter or module.exports.userRouter = userRouter
- then import via const userRouter = require('./router/user_router.js')const userRouter = require('./router/user_router.js').userRouter;
#### Error-handling middleware
- bound w app.use or router.use()
- error routers always take 4 parameters
![[Pasted image 20250722013024.png]]

#### Built-in middleware
- can be bound to either entire app, or to specific routers 
- useful for activities, e.g. 
	- rendering html pages (static files) from server,
	- parsing JSON input from frontend
	- cookie parser
- **express.static** is middleware that tells Express server: "If a browser asks for a file that exists in _this specific directory_ (`cad220_staticfiles`), just send that file directly to the browser, as-is."
![[Pasted image 20250722124918.png]]

#### 3rd Party Middleware
- Open source, third party, user defined
- npm install
- function that takes 3 parameters:
	- request
	- response
	- next
- define method that takes these 3 params and bind it w/ app.use or router.use
![[Pasted image 20250722132548.png]]

NOTE: the order of middleware and route handling is top-bottom in code
NOTE: app.use() is for mounting middleware functions at specified path or globally for all paths
- function requires either one middleware function with 3 params, or a path and then middleware func


### Template rendering:
- ability of server to fill in dynamic content in the HTML template
- ex: express-react-views
	- renders React components from server
![[Pasted image 20250722134208.png]]
- render() looks for template named :name under /index and pass dynamic prop {name} to it


# Authentication and Authorization in Node.js
- session-based auth
	- creation, storage, and destruction of session IDs
- contrasted with Token-based auth and passwordless auth
	- highlighting use of JWTs and public and private key pairs

Authentication:
- verifies user's identity using credentials
- ensures only authorized users access system
- handles verification via backend

3 Popular authentication methods in Node.js:
- Session-based
- Token-based
- Passwordless

### Session-based:
- one of earliest methods
	- user logs w/ creds
	- creds checked against database
	- session ID created and stored in db AND browser cookies
	- session ID destroyed on logout or expiration
		- logs out browser and database

```
const express = require('express');
const session = require('express-session');
const app = express();
// Middleware to set up session management
app.use(session({
	secret: 'secret-key', // strong-secret key for encrypting session data
	resave: false,        // whether save session data if no modifications
	saveUninitialized: true, // whether save new but not modded sessions
	cookie: { secure: false }, // set to true in prod w/ HTTPS
	rolling: true // session cookie's expiration date reset every req
}));

// Effectively, every request has req.session property

// POST endpoint for handling login
app.post('/login', (req, res) => {
	const { username, password } = req.body;
	// Simulated user auth (replace w/ actual logic)
	if (username === 'user' && password === 'password') {
		req.session.user = usernamel // Store user info in session
		res.send('Logged in successfully');
	} else {
		res.send('Invalid creds');
	}
});

// GET endpoint for accessing dashboard
app.get('/dashboard', (req, res) => {
	if (req.session.user) {
		res.send('Welcome ${req.session.user}'); // Display welcome msg
	} else {
		res.send('Please login');
	}
})
```

- for every request, middleware runs
	- this can be problem for large scale apps with mult server isntances,
		- use Redux or change system
- it looks for session cookie
	- if none exists, create empty req.session object
	- pass req.session object to route handler
	- route handler checks for req.body

NOTE:
- new session is created when req.session is modified and session is new
- express-session will:
	- generate unique session ID
	- store session data (including req.session.user) in your configured session store (memory, Redis, database)
	- Add the Set0Cookie header to outgoing HTTP response w/ new session ID
- cookie is set automatically by middleware

- if existing session's data is modified:
	- req.session is updated in the store, and if cookie's expiration needs to be refreshed, it will also add a Set-Cookie header to response to potentially update cookie in browser


### Token-based authentication
2 key concepts:
-  authentication and authorization
- Authentication: user provide creds and receive token that validates creds
- Authorization: use token to access resources, ensuring resource server knows which resources you're permitted to access

Tokens contain 3 parts:
- Header: contains token type and algorithm used
- Payload: includes user attributes, known as claims, such as permissions & expiration times
- Signature: ensures token's integrity during transit
Header.Payload.Signature

Jot, pronounced, jot, and written as JWT, is:
- INTERNET STANDARD for creating JSON payload data
- In token-based authentication

### 2 Tokens Types:
- **ID Token:**
	- What is it?
		- verifies end-user's identity to client app (PROOF OF AUTHENTICATION)
	- How is it checked?
		- frontend client receives and verifies it to confirm user's login and display basic user info
	- What does it contain?
		- claims about user's id (sub, iss, aud, exp, name, email, picture) 
	- In what context to use?
		- For OpenID Connect flows (OIDC) (Login with Google - any Auth0)
	
- **Access Tokens:**
	- What is it?
		- grants access to protected resources (APIs)
	- How is it checked?
		- client sends it to API (resource server) in Authorization: Bearer header for every request to protected endpoints
		- **Permissions info:** Token contains user perms details w/o need for perms from authorization server
		- **Security feature**: Token encryption protects user creds even if stolen
	- What does it contain?
		- claims about perms or scopes (sub, scope, roles, exp)

**When are the tokens generated?**
- Browser calls authentication server
- Upon successful authentication, Authorization Server generates BOTH ID Token and Access Token
- It signs both JWTs
- It sends both tokens back to client app (often along w/ Refresh Token if flow supports it)

**How the Client Receives. Stores, and Uses Them:**
- Client receives both tokens
	- ID Tokens NOT usually stored, since it is just to prove user id at moment of authN
	- Stores access tokens either via HttpOnlyCookies, localStorage, or sessionStorage (or local variables, not usually tho)
- It verifies ID Token to confirm user's id and update its UI (show "Logged in ... ")
- It stores Access Token for making subsequent requests to protected API endpoints

**How Does Client Verify ID Token?**
Even though the token came from a trusted source (the Authorization Server), the client receives it over an untrusted network (the internet). The client needs a way to **cryptographically confirm** that:
- "This token truly came from Auth0 (or my Express backend)."
	- Checks digital signature by using Auth Server's public key
- "This token hasn't been altered by anyone in transit."
	- via digital signature
- "This token is indeed meant for _me_ (this client app) to consume."
	- via `aud` claim

**Ways of Access Token Storage:**
1. **`HttpOnly` Cookies:**
    - **How:** Set by the server via `Set-Cookie` header. Browser sends automatically. **JavaScript CANNOT access.**
    - **Pros:** **Strongest protection against XSS (Cross-Site Scripting)** because scripts can't read them.
    - **Cons:** Vulnerable to **CSRF (Cross-Site Request Forgery)** if not combined with `SameSite` attribute and/or CSRF tokens.
2. **`localStorage`:**
	- **How:** Stored by JavaScript in the browser's persistent storage.
	- **Pros:** Easy to use with JavaScript, **persists across browser tabs and sessions.**
	- **Cons:** **Vulnerable to XSS (Cross-Site Scripting)**, as any malicious script can easily read the token.
3. **`sessionStorage`:**
	- **How:** Stored by JavaScript in the browser's temporary storage.
	- **Pros:** Easy to use with JavaScript.
	- **Cons:** **Vulnerable to XSS (Cross-Site Scripting)**. Data is **cleared when the browser tab/window is closed**, meaning tokens don't persist across sessions.

### **User Flow: Token-Based Authentication & Authorization**
1. **User Registration (Optional, First Time User):**
    - User provides credentials (username, password) to the client.
    - Client sends credentials to the server's `/register` endpoint.
	    - OR to Authorization Server (e.g., Auth0 (bouncer))
    - Server/AuthO Server hashes the password, stores user info in the database.
    - Server/AuthO Server sends registration success response. (No token or session yet).
2. **User Login (Authentication - AuthN):**
    - User provides credentials (username, password) to the client.
    - Client sends credentials to the server's `/login` endpoint.
	    - OR to Auth0 Server for login
    - Server verifies credentials against the database (password hashing comparison).
    - **If successful:**
        - Server retrieves user's roles/permissions from the database.
        - Server generates a **JWT ID Token** (containing claims: name, email)
        - Server generates a **JWT Access Token** (containing claims: user ID, roles, permissions, expiration) and cryptographically signs it.
        - Server sends the Access Token (and often a Refresh Token) back to the client.
    - **If unsuccessful:**
        - Server sends an "Invalid credentials" error response.
3. **Client-Side Token Storage:**
    - Client receives the ID Token, Access Token (and Refresh Token).
    - Client **verifies and uses the ID Token to establish user identity** (e.g., display "Welcome, [User Name]" in the UI).
    - Client **stores the Access Token** (e.g., in an `HttpOnly` cookie for security, or `localStorage`/`sessionStorage` with XSS precautions).
4. **Accessing Protected Resources (Authorization - AuthZ):**
    - User attempts to access a protected resource or API endpoint.
    - Client retrieves the **Access Token** from storage.
    - Client sends the Access Token with the request (typically in the `Authorization: Bearer` header) to the server.
5. **Server-Side/Back-end API Token Verification & Authorization:**
    - Server/API receives the request with the Access Token.
    - Server extracts the Access Token.
    - Server **verifies the token's cryptographic signature** (ensuring integrity and authenticity).
    - Server **checks the token's expiration time**.
    - **If token is valid and unexpired:**
        - Server/API decodes the token's payload to extract claims (user ID, roles, permissions)
        - Server uses these claims to determine if the user is **authorized** to access the specific resource or perform the requested action.
        - If authorized: Request processed, resource returned.
        - If unauthorized: Server sends a `403 Forbidden` response.
    - **If token is invalid or expired:**
        - Server sends a `401 Unauthorized` response.
6. **Token Refresh (Optional, for long sessions):**
    - If the Access Token expires, but the Refresh Token is still valid:
        - Client sends the Refresh Token to a dedicated `/refresh-token` endpoint on the server.
	        - OR to AuthO's token endpoint
        - Server/AuthO Server validates the Refresh Token.
        - I**f valid:** Server issues a **new, short-lived Access Token** (and optionally a new Refresh Token).
        - Client stores the new Access Token and retries the original request.
7. **User Logout:**
    - User initiates logout from the client.
    - Client sends a request to the server's `/logout` endpoint.
	    - OR to AuthO
    - Server invalidates the Refresh Token (if used) in its database.
    - Server instructs the client to clear the Access Token from its storage (e.g., by clearing the cookie or `localStorage`).
    - Server sends a logout success response.
### Access token vs Refresh Token
- refresh is given to deal with short expiry of refresh tokens
	- Stateful: kept track of by server
- access token:
	- Stateless: server verifies signature and expiration

|Feature|Access Token|Refresh Token|
|---|---|---|
|**Primary End**|**Short Expiration (`exp` claim)**|**Server-Side Revocation (on Logout/Security Events)**|
|**On Logout**|Client-side deletion (from storage)|**Server-side deletion/invalidation** + Client-side deletion|
|**On Tab Close**|Gone if `sessionStorage`/in-memory; persists if `localStorage`/persistent cookie.|Gone if `sessionStorage`/in-memory; persists if `localStorage`/persistent cookie (common `HttpOnly` cookie).|
|**Server State**|**Stateless** (usually)|**Stateful** (tracked in DB for revocation)|
Code snippet:
```
const express = require('express');
const jwt = require('jsonwebtoken');
const bodyParser = require('body-parser'); // middleware
const app = express();
app.use(bodyParser.json());
const secretKey = 'your-secret-key'; // Replace w/ strong secret key
// POST endpoint for user login and JWT generation
app.post('/login', (req, res) => {
	const { username, password } = req.body;
	// Simulated user authN
	if ( username === 'user' && password === 'password' ) {
		// Generate JWT w username payload
		const token = jwt.sign({ username }, secretKey, { expiresIn: '1h'});
		res.json({ token}); // Send token as JSON response	
	}
})

// GET endpoint to access protected resource (dashboard)
app.get('/dashboard'. (req, res) => {
	// Get token from AuthZ header
	const token = req.headers['authorization'];
	if (token) {
		// Verify JWT token
		jwt.verify(token, secretKey, (err, decoded) => {
			if (err) {
				...
			}
		})	
	}
})
```


### Passwordless authentication
- No traditional passwords needed
- Uses biometrics, magic links, or 1-time passcodes
- Utilizes **public/private key encryption for security**

Registration:
- Device generates a private key/public key pair
- pair utilizes a factor to prove your identity
- public key is available to anyone
- public key encrypts data 
- private key is securely stored on your device
- private key decrypts data
![[Pasted image 20250722190358.png]]

Verification:
- Application generates a login challenge
- Challenge is encrypted w/ public key
- private key decrypts challenge
- Response is used to authorize the user
![[Pasted image 20250722190342.png]]

### Password Authentication Implementation in Express App:
const express = require('express');
const bodyParser = require('body-parser'); // middleware
const nodemailer = require('nodemailer');
const app = express();
app.use(bodyParser.json());

const users = {}; // In-memory storage for demo purposes
// Endpoint to request access and send verification code via email
app.post('/request-access', (req, res) => {
	const { email } = req.body;
	// Generate a 6-digit verification code
	const code = Math.floor(100000 + Math.random() * )
})


CRUD LAB:
- object of key value pairs
```
const friends = {
	'email': {'firstName': 'John', ... , }
}	
```

Update:
`friends['email']['firstName'] = 'Not John'

Delete:
`delete friends['email']`

Sending Response:
`res.send(JSON.stringify(friend, null, 4));
`res.json(friend)
`res.status(404)

Crud ex:
```
const express = require('express');

  

const router = express.Router();

  

let friends = {

    "johnsmith@gamil.com": {"firstName": "John","lastName": "Doe","DOB":"22-12-1990"},

    "annasmith@gamil.com":{"firstName": "Anna","lastName": "smith","DOB":"02-07-1983"},

    "peterjones@gamil.com":{"firstName": "Peter","lastName": "Jones","DOB":"21-03-1989"}

};

  
  

// GET request: Retrieve all friends

router.get("/",(req,res)=>{

  
  

  res.send(JSON.stringify(friends, null, 4));//This line is to be replaced with actual return value

});

  

// GET by specific ID request: Retrieve a single friend with email ID

router.get("/:email",(req,res)=>{

    let email = req.params.email;

    if (friends[email]) {

        friend = friend[email];

        res.json(friend);

    } else {

        res.status(404).send('Friend not found');

    }

});

  
  

// POST request: Add a new friend

router.post("/", function(req, res) {

    // Check if email is provided in the request body

    if (req.body.email) {

        // Create or update friend's details based on provided email

        friends[req.body.email] = {

            "firstName": req.body.firstName,

            "lastName": req.body.lastName,

            "DOB": req.body.DOB,

        };

    }

    // Send response indicating user addition

    res.send("The user" + (' ') + (req.body.firstName) + " Has been added!");

});

  
  

// PUT request: Update the details of a friend with email id

router.put("/:email", function(req, res) {

    // Extract email parameter from request URL

    const email = req.params.email;

    let friend = friends[email];  // Retrieve friend object associated with email

  

    if (friend) {  // Check if friend exists

        let DOB = req.body.DOB;

        let firstName = req.body.firstName;

        let lastName = req.body.lastName;

  

        // Update DOB if provided in request body

        if (DOB) {

            friend["DOB"] = DOB;

        }

        if (firstName) {

            friend["firstName"] = firstName;

        }

        if (lastName) {

            friend["lastName"] = lastName;

        }

  

        friends[email] = friend;  // Update friend details in 'friends' object

        res.send(`Friend with the email ${email} updated.`);

    } else {

        // Respond if friend with specified email is not found

        res.status(404).send("Unable to find friend!");

    }

});

  
  

// DELETE request: Delete a friend by email id

router.delete("/:email", (req, res) => {

    let email = req.params.email;

    if (friends[email]) {

        delete friends[email];

        res.send(`Friend with email ${email} has been deleted.`)

    } else{

        res.status(404).send("Friend not found");

    }

});

  

module.exports=router;
```

**Session authentication with access token:**
```
const express = require('express');

const jwt = require('jsonwebtoken');

const session = require('express-session')

const routes = require('./router/friends.js')

  

let users = []

  

// Check if a user with the given username already exists

const doesExist = (username) => {

    // Filter the users array for any user with the same username

    let userswithsamename = users.filter((user) => {

        return user.username === username;

    });

    // Return true if any user with the same username is found, otherwise false

    if (userswithsamename.length > 0) {

        return true;

    } else {

        return false;

    }

}

  

// Check if the user with the given username and password exists

const authenticatedUser = (username, password) => {

    // Filter the users array for any user with the same username and password

    let validusers = users.filter((user) => {

        return (user.username === username && user.password === password);

    });

    // Return true if any valid user is found, otherwise false

    if (validusers.length > 0) {

        return true;

    } else {

        return false;

    }

}

  

const app = express();

  

app.use(session({secret:"fingerpint"},resave=true,saveUninitialized=true));

  

app.use(express.json());

  

// Middleware to authenticate requests to "/friends" endpoint

app.use("/friends", function auth(req, res, next) {

    // Check if user is logged in and has valid access token

    if (req.session.authorization) {

        let token = req.session.authorization['accessToken'];

  

        // Verify JWT token

        jwt.verify(token, "access", (err, user) => {

            if (!err) {

                req.user = user;

                next(); // Proceed to the next middleware

            } else {

                return res.status(403).json({ message: "User not authenticated" });

            }

        });

    } else {

        return res.status(403).json({ message: "User not logged in" });

    }

});

  

// Login endpoint

app.post("/login", (req, res) => {

    const username = req.body.username;

    const password = req.body.password;

  

    // Check if username or password is missing

    if (!username || !password) {

        return res.status(404).json({ message: "Error logging in" });

    }

  

    // Authenticate user

    if (authenticatedUser(username, password)) {

        // Generate JWT access token

        let accessToken = jwt.sign({

            data: password

        }, 'access', { expiresIn: 60 * 60 });

  

        // Store access token and username in session

        req.session.authorization = {

            accessToken, username

        }

        return res.status(200).send("User successfully logged in");

    } else {

        return res.status(208).json({ message: "Invalid Login. Check username and password" });

    }

});

  

// Register a new user

app.post("/register", (req, res) => {

    const username = req.body.username;
    const password = req.body.password;

    // Check if both username and password are provided

    if (username && password) {
        // Check if the user does not already exist

        if (!doesExist(username)) {
            // Add the new user to the users array
            users.push({"username": username, "password": password});
            return res.status(200).json({message: "User successfully registered. Now you can login"});
            
        } else {
            return res.status(404).json({message: "User already exists!"});
        }
    }
    // Return error if username or password is missing
    return res.status(404).json({message: "Unable to register user."});
});

const PORT =5000;

app.use("/friends", routes);

app.listen(PORT,()=>console.log("Server is running"));```
# FINAL PROJECT
In this final project, we will build a server-side online book review application and integrate it with a secure REST API server which will use authentication at session level using JWT. You will then test your application using Promises callbacks or Async-Await functions.
```

Tips:
- you can't filter on an object, only array
- instead, try obtaining keys via
	- Object.keys(object).forEach()