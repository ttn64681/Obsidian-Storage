- **JWT Generation (/login)**: Handles POST requests for user login. If credentials are valid, it generates a JWT (token) containing the username (jwt.Sign ({ username }, secretKey, { expiresIn: '1 h' })).

- **JWT Verification (/dashboard)**: Checks for a JWT in the Authorization header of incoming requests (const token = req. Headers['authorization']). If present, it verifies the token (jwt.Verify (token, secretKey)) and extracts the username (decoded. Username) to grant access.
### Passwordless Authentication Implementation in Express App:
- Express app setup w JSON requests parsing middleware
- /request-access: Generates and stores a verification code
- /verify-code
```
const express = require('express');
const bodyParser = require('body-parser'); // middleware
const nodemailer = require('nodemailer');
const app = express();
app.use(bodyParser.json());

const users = {}; // In-memory storage for demo purposes
// Endpoint to request access and send verification code via email
app.post('/request-access', (req, res) => {
    const { email } = req.body;
    // Generate a 6-digit verification code
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    // Store the code in memory (users object)
    user[email] = code;
})

// Endpoint to verify the received code
app.post('/verify-code', (req, res) => {
	const { email, code } = req.body;
	// Compare the received code w stored code for the email
	if (users[email] === code) {
		// Code matches, access granted
		res.send('Access granted')};
	else { res.send('Access denied')};
})
```


RECAP:
- Authentication confirms user's id using creds
- Session-based authN uses creds to create session ID stored both in db and browser, when user logs out, session ID destroyed
	1. The user uses their credentials to log in.
	2. The login credentials are verified against the credentials in a database. The database is responsible for storing which resources can be accessed based on the session ID.
	3. The server creates a session with a session ID that is a unique encrypted string. The session ID is stored in the database.
	4. The session ID is also stored in the browser as a cookie.
	5. When the user logs out or a specified amount of time has passed, the session ID is destroyed on both the browser and the database.
- Token-based uses access tokens (often JWTs) that get passed b/w server and client securely w/ the data that is passed b/w the two
	- Token-based security entails two parts: authentication and authorization. Authentication is the process of providing credentials and obtaining a token that proves the user's credentials. 
	- Authorization refers to the process of using that token so the resource server knows which resources the user should have access to.
	- Token-based authentication **uses access tokens** to validate users. 
		- An **access token** is a small piece of code that contains information about the user, their permissions, groups, and expirations that get passed from a server to the client. 
			- The Authorization server creates an access token (note that the ID token and access token are two separate objects) and sends the access token back to the client, where the access token is stored.
			- Then, when the user makes requests or resources, the token is passed to the resource, also called an API server.
			- The token gets passed with every HTTP request.
			- The token contains embedded information about the user's permissions without the need to access those permissions from the authorization server.
			- Even if the token is stolen, the hacker doesn't have access to the user's credentials because the token is encrypted.
		- An **ID token** is an **artifact** that proves that the user has been authenticated.
	- 
- Passwordless authN uses pub/priv key pairs to encrypt and decrypt data passed between client and server without the need for a password.
	- User does not need login credentials, but rather, they gain access to the system by demonstrating they possess a factor that proves their identity.
	- Common factors include biometrics such as a fingerprint, a "magic link" sent to their email address, or a one-time passcode sent to a mobile device. Password recovery systems now commonly use passwordless authentication.
	- **is achieved using Public Key and Private Key Encryption.**

# Authentication in Node. Js
- Discuss advantages of token-based authN in Node. Js
- Implement token-based authN and authR in Node. Js

 Authentication:
 - Process confirming user's id by obtaining creds and using creds to validate id
 - Meant to ID users and provide access rights
1. Session-based
2. Token-based
	- Scalable, only needs to be on client side (stateless)
		-  server only needs to verify token along w/ user info => handle mult users
	-  flexibility, can be used across mult servers 
		- (asymmetric signing via pub/priv key pair)
			- Private key signs token, public key is validated by other servers locally, w/o needing to contact authN server (except for initial key acquisition)
	- JWT can be signed and encrypted
		- They can't be tampered w/ and cannot be read w/o priv encryption key
3. Passwordless

### AuthN Express API server overview
Ex:  providing access to employee info based on their usage right
Structure:
- 2 APIs:
	- POST API -
		- For logging in
		- Returns web token to sign in by sending user pwd in req. Body
		- Endpoint:
			- Signin/
	- GET API -
		- Resource endpoint to get employee info that only authN users
		- Endpoint:
			- Employee/
```
express = require('express');
app = express();

app.get('/employee/, (req, res) => {
	return res
		.status(401
		.json({ message: "Please login to access this resource" });
});

myapp.listen(5000, () => {
	console.log("API Server is localhost:5000");
})
```
Verify the endpoint w/ cURL:
- To execut API, save file and name it apiServer. Js
- Then run the command:
	- Node apiServer. Js
- To verify endpoint can't be accessed unless user is authorize, run cURL command
	- Curl -i localhost: 5000/employee
		- -i => include HTTP response headers in output

### Generate JSON web token (JWT)
- Allows users to sign in sending user pwd and send back verified generated token as long as user pwd correct
- Npm install -save jsonwebtoken (generates JWTs)

Const express = require ('express');
Const jsonwebtoken = require ('jsonwebtoken');
Consst JWT_SECRET = "aVeryVerySecretString" ***// should ALWAYS be generated using pwd generator and stored in config file as env var and not hardcoded***

Const app = express ();
App.Use (express.Json ());

Myapp.Post ('/signin', (req, res) => {
	const { uname, pwd } = req. Body;
	if (uname === "user" && pwd === "password") {
		Return res.Json ({ 
			Token: jsonwebtoken.Sign ({ user: "user" }, JWT_SECRET)
		}); // sends token as response
	} else {
		Return res
			. Status (401)
			. Json ({ message : "Invalid user and/or pwd" });
	}
});

Myapp.Get ('/employees', (req, res) => {
	Let tkn = req.Header ('Authorization');
	If (! Tkn) return
		Res.Status (401). Send ("No Token");
	 If (tkn.StartsWith ('Bearer ')) {
		 TokenVal = tkn.Slice (7, tkn. Length). TrimLeft ();
	 } // serverside storage
	Try {
		Const verificationStatus = jsonwebtoken.Verify (tokenVal, JSON_SECRET);
		If (verificationStatus. User === 'user') {
			Return res.Status (200). Json ({ message: "Access Successful to Employee Endpoint" });
		} else {
			Return res.Status (401). Json ({ message: "Please login to access this resource" });
		}
	} catch (err) {
		Return res.Status (401). Json ({json ({ message: "Please login to access this resource" });
	}
});

Myapp.Listen (5000, () => {
	Console.Log ("API Server is localhost: 5000");
});

# HTTP Methods and REST APIs
Internet relies on client-server arch:
- End-user interfaces w/ client, servers house services that operate apps, business logic, and data
- Clients communicate with the servers to achieve desired functionality for the end user
- Data is transferred between client and server using hypertext transfer protocol
	- Usually via APIs
	- Guidelines for writing these APIS include REST APIs

There are five requirements for an API to be considered  
RESTful, plus one optional criterion:

1. The API leverages a client-server architecture made up of resources that are managed and  
    Delivered via HTTP.
2. Communication between client and server is **stateless**
3. Data is **cacheable** to improve performance on the client side.
4. The interface is transferred in a standard format such that the requested resources stored on the server are separated from the representation sent to the client. The representation sent to the client contains sufficient data so that the client can manipulate the representation.
5. Requests and responses communicate through different layers, such as **middleware**. The client and server often do not communicate directly with each other.
6. (Optional) Resources are usually static but can also contain executable code. The code should only be executed when the client requests it.





# Express best practices
### Web framework directory structures
- Most web frameworks have required directory structures
- Epxress doesn't require
- Still best to define structure in advance for growth and maintenance

### Suggested Express folder structure:
- Project
	- Node_modules
		- App's modules and pkgs
		- Automatically created after running npm install
	- Config
		- Database connections
		- Env vars
		- Credential files including API keys for external services
	- Models
		- Contains data models
		- Data models specify type of data store defined by ORM library
	- Routes
		- Specify routes for all entities
		- One file for each logical set of routes
	- Views
		- Templates
		- Templates dynamically write HTML, CSS, and JS for client
	- Public
		- Contains static content such as images, CSS, and JS
		- Helpful to have sub-folder for each type of content
	- App. Js
		- Main config file
	- Routes. Js
		- Central location to access all routes in app
		- Requires or imports all files in routes folder and exports them as single module to app. Js
		- Creates single point of entry for all routes
	- Package. Json
		- Metadata to manage dependencies

- API directory structure
	- Node_modules
	- Config
	- Models
	- Routes
	- App, js
	- Routes. Js
	- Package. Json

#### When naming routes:
- Use noun as resource identifier

| HTTP method 'n route                | Action                     |
| ----------------------------------- | -------------------------- |
| POST/employee or<br>PUT/employee: id | create new employee        |
| GET/employees                       | Retrieve list of employees |
| GET/employee/: id                    | Retrieve an employee       |
| PATCH/employee/: id                  | Modify an employee record  |
| DELETE/employee/: id                 | Remove an employee         |

HTTP status codes:
200 s - everything is OK
300 s - Resource has been moved
400 s - Client-side error
500 s - Server-side error

### Testing REST APIs
- Black-box testing REST APIs
	- Test code without looking at internal structure
	- Test as whole w/o mocked or stubbed dependencies
	- Mocha framework contains a module called **SuperTest**
		- Provides way to test HTTP requests (perfect for black-box testing REST APIs)


#### API authentication
- When API needs to authenticate, best practice to use:
	- JWT based stateless authN
		- Since REST APIs must be stateless, your authN will need to be as well
		- Stateless authN verifies users by supplying most of the session info (user props provided on client-side)

#### API documentation
- Provide appropriate documentation for your REST APIs
- Documentation open-source projects:
	- API Blueprint (apiblueprint. Org)
	- Swagger (swagger. Io)

Using Node Package Manager (npm)
- Use npm init when initializing
- Use --save or --save-dev when installing dependencies
	- Make sure correct dependencies are installed when moving to different platform
- Never push node_modules repository
- Always use npm to install pkgs

Naming conventions:
- Lowercase for file names
- Camel case for vars
- Lowercase separated by dashes for npm modules
- Camel case when requiring npm modules


# Module Summary

Congratulations! You have completed this module. At this point in the course, you know:

- Developers rely on third-party packages to extend Node. Js. 
    
- You can use the npm application to manage Node. Js packages in your Node. Js framework installation.
    
- The MVC architecture style divides a back-end application into three parts: the model, the view, and the controller.
    
- REST API frameworks use HTTP methods to communicate with each other.
    
- Express abstracts low-level details. 
    
- Routing can be handled at the application level or at the router level. 
    
- Five types of middleware are application level, router level, error handling, built-in middleware, and third party. 
    
- Template rendering is the ability of the server to fill in dynamic content. 
    
- The npm jsonwebtoken package should be required in an Express application to authenticate a user.

Test-project/
   Node_modules/
   Config/
     Db. Js           //Database connection and configuration
     Credentials. Js  //Passwords/API keys for external services used by your app
   Models/            //For mongoose schemas
      Items. Js
      Prices. Js
   Routes/           //All routes for different entities in different files
      Items. Js
      Prices. Js
   App. Js
   Routes. Js         //Require all routes in this and then require this file in
   Package. Json

**Disadvantages of manual parsing:**
- String matching ignores the structure of XML data
- The message body might contain malformed XML data
- String matching could be more efficient than building an XML tree of the data
- String matching is less tolerant to changes in XML data structure
- If message adds or removes any XML elements, you must change regular expression on string match function

![[Pasted image 20250807175930.png]]

FINAL PROJECT:

```
let friends = {
	"johnsmith@gamil.com": {"firstName": "John","lastName": "Doe","DOB":"22-12-1990"},
	"annasmith@gamil.com":{"firstName": "Anna","lastName": "smith","DOB":"02-07-1983"},
	"peterjones@gamil.com":{"firstName": "Peter","lastName": "Jones","DOB":"21-03-1989"}
};

// GET request: Retrieve all friends
router.get("/",(req,res)=>{
res.send(
	JSON.stringify(friends, null, 4)
});
```

- res.send (JSON.Stringify (friends, null, 4)) ===
- res.json (friends)