1. Node.js and SS JS
2. Async programming via callback funcs
3. Express Web App Framework
4. Week 4, Book Review App Project

- Develop applications using asynchronous callbacks and promises
- Create REST APIs and perform CRUD operations
- Implement authentication and session management
<hr>

# What is it?
Front-end client (Browser engine) vs Back-end server (communicates w browser engine)

Technologies:
- Includes: servers, databases, web APIs, programming langs, frameworks, and runtimes
- Servers can refer to hardware, software, or both
- Servers communicate w/ and provide functionality to a client
- Servers also comm w/ and provide functionality to each other

Types of Servers:
- Database
	- House, retrieve, and deliver data
	- Database server and 'database' often used interchangeably
- Application
	- ***Host and deliver the application thru HTTP***
	- ***They sit between database server and a web server***
	- ***transform data into content***
	- execute server-side app logic ("business logic") to generate **dynamic content**
		- receives requests from web server, runs code, processes data, then generates response
	- often intertwined w web server, as it also uses HTTP (high level response generation) and API logic
	- Business logic:
		- data storage rules
		- data transfer rules
- Web
	- serving static content to client browser
	- Web server ensure client requests are responded to
		- often using HTTP (low level, connection, protocol handling).
		- HTTP server is part of software running on web server (Node fetch request code, Express Endpoint configuration)
		- Software part of web server controls how user accesses files hosted on server
		- Hardware part of web server is either your local computer or a cloud hosting service

Web APIs
- How 2 pieces of software comm
- Web services:
	- are type of web API
	- Communicate using HTTP
	- is the programming interface that sends and receives requests using HTTP among web servers and client

Back-end languages:
- JS, PHP, Python, Ruby, Java, C#

Frameworks:
- provide structure for code
- generates code that cant be altered
- Django (Python), Ruby on Rails (ruby), Express.js  (JS)

Express.js:
- framework on top of Node.js
- Handles HTTP requests made to web server

Runtime Environments:
- Mini OS that provides resources necessary for app to run
- infrastructure that supports execution of codebase
- Environment in which an app gets executed
- Node.js is back-end runtime environment

Node.js
- Chrome V8 engine
- v8 also runs on client front end browser
- executes JS
- JS used both front and backend

Backend responsibility:
- Load:
	- Number of concurrent users
	- Number of concurrent transactions
	- Amount of concurrent data transfer between clients and servers
- Scalability:
	- Application's ability to handle changes in load w/o affecting performance
	- Essential for client-server app success

Other backend responsibilities:
- security
- authentication
- malware prevention
- performance

# Back-end Front-end Dev Overview:
#### Key Components of Back-end Development:

1. **Server:** The hardware or software that provides resources, data, services, or programs to clients over a network.
2. **Database:** A structured collection of data that can be easily accessed, managed, and updated.
    - **SQL Databases:** Relational databases like MySQL, PostgreSQL, and SQLite.
    - **NoSQL Databases:** Non-relational databases like MongoDB, Cassandra, and Redis.
3. **Server-Side Languages:** Programming languages used to build the back-end logic.
    - **Node.js:** JavaScript runtime built on Chrome's V8 JavaScript engine.
    - **Python:** A high-level programming language known for its readability and efficiency.
    - **Ruby:** A dynamic, open-source programming language with a focus on simplicity.
    - **Java:** A versatile and powerful programming language used for large-scale applications.
4. **Frameworks and Libraries:**
    - **Express:** A minimal and flexible Node.js web application framework.
    - **Django:** A high-level Python web framework that encourages rapid development.
    - **Ruby on Rails:** A server-side web application framework written in Ruby.
    - **Spring:** A comprehensive framework for enterprise Java development.
![[pgtr5g4q.png]]
![[bknylbvb.png]]
#### Importance of a Robust, Scalable Back-end:
A robust back-end ensures data security, performance, scalability, and smooth application logic. It supports user interactions, handles business logic, and integrates with front-end systems.

## Front-end Development

Front-end development, also known as client-side development, involves creating the part of a website or application that users interact with directly. This includes everything the user experiences visually and through interactions.
#### Key Components of Front-end Development:
1. **HTML (HyperText Markup Language):** The structure of web pages, defining elements such as headings, paragraphs, images, and links.
2. **CSS (Cascading Style Sheets):** The styling of web pages, including layout, colors, fonts, and responsiveness.
3. **JavaScript:** The behavior of web pages, enabling interactive features like forms, animations, and dynamic content updates.
4. **Frameworks and Libraries:**
    - **React:** A JavaScript library for building user interfaces.
    - **Angular:** A TypeScript-based framework for building web applications.
    - **Vue.js:** A progressive JavaScript framework for building user interfaces.
![[utr4obmn.png]]
![[s60hszhd.png]]

# Getting Started w/ Node.js
## Full-stack App
- Client-side
	- website and mobile app that are user-facing
- Server-side
	- Processes any requests from the client-side and sends responses back to client
	- Today, cloud hosts web server, app server, and database

![[uyultbt4.png]]

- non-blocking behavior enables the server to remain responsive and handle multiple tasks concurrently, akin to a multi-threaded environment.

JSON Payload:
- The payload represents the data transmitted between the client and the server. When the client needs to send data to the server, it does so in the form of a JSON object, as illustrated in the example below:
{
    "name": "John",
    "age": "24",
    "email": "johnparker@gmail.com"
}

{
    "status": "ok",
    "message": "Successfully added"
}

### Express Framework

While Node.js provides packages to create a server, the Express framework simplifies the process of creating APIs and endpoints. An API endpoint is a specific point of entry for a request from the client to the server.
### Next steps
In this course, you will learn how to perform server-side coding with Node.js using the Express framework.


<hr>
# Intro to Node.js
Differences b/w JS and Node.js

- open-source lang that runs on V8
- V8 is open-source engine developed by Google for Google Chrome browser

Node.js functionality:
- devs frequently use JS to code client-side cpaabilities.
- Node.js is the server component in same lang
- Node.js is event-driven and uses async, non-blocking I/O

JS w/ Node.js
Node apps process and route web service requests from client

Example:
- Web Browser
	1. User selects option in user UI written in HTML CSS
	2. user action triggers JS code that implements business logic on client-side (e.g. input validation)
		4. REST web service processes request and returns result to client as JSON payload over HTTP
- Node Server
	- Node application
		3. JS app makes web service call over HTTP w JSON data payload
		- the REST web service, part of Node.js app running on Node server, receives HTTP request

Node.js usage:
- Devs can now use Node.js in the same components of the architecture where they use Java, Perl, C++, Python, and Ruby
- Used in prod by companies like Uber, Yahoo!, LinkedIn, GoDaddy, eBay, and PayPal

Express.js
- Configurable framework for building apps on Node.js
- Abstracts lower-level APIs in Node.js by using HTTP utility methods and middleware
- Simplifies app dev on Node.js

<hr>
***Node.js concepts:***
- public folder
	- public assets like image, CSS, and Java
- templates or views
	- server-rendered HTML that is sent back to client in response to requests
- Routes 
	- defines endpoints that accept and process client requests
- Server.js
	- file that contains main app code
- Package.json
	- contains metadata info about project including dependencies, scripts, etc.
<hr>

Introductory Thoughts on Server-Side JS and Node.js
- same code scanning and code testing for front and backend
- unified approach ton dependencies and packages
- abundance of packages like npm
- fits well with microservices

# Import and Require
- what is a module
- what is a module specification
- what is import() and require() for?

Modules:
- related, encapsulated JS code
- Serves a single purpose
- Can be single file or folder containing files
- Reusable
- breaks down complex code into manageable chunks

Purpose of import() and require()
- when an external app needs to use code in a module
- use either import() or require() depending on specification

Specifications and Packages:
- **Package: a directory w/ one or more modules bundled together**
- Module Specifications:
	- conventions and standards used to create packages
	- ***Conventions/Standard modules:***
		- ***CommonJS modules***
		- ***ES modules***

Enabling ES modules -
By Default, Node.js treats JS code as a CommonJs module
- Enable ES modules
- Library authors can easily enable ES modules in a Node.js package by changing pkg file extension **from packagename.js (CommonJS)** to **packagename.mjs (ES)**

Importing and exporting Modules:
- ***CommonJS modules use require() statement to import modules*** whereas ES modules use import() function
- When a module is needed outside its own file, it must be exported first
- module.exports statement should be used with CommonJS
- Modules can be exported to an ES specification using "export"

|                      | CommonJS       | ES       |
| -------------------- | -------------- | -------- |
| Import module        | require()      | import() |
| Export from a module | module.exports | export   |

| require()                                                                                                                                                                     | import()                                                                                                                                                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| can be called anywhere in code                                                                                                                                                | can be called only at beginning of file                                                                                                                                           |
| can be called w/ conditionals and functions                                                                                                                                   | can't be called w/in conditionals or funcs                                                                                                                                        |
| dynamic                                                                                                                                                                       | static                                                                                                                                                                            |
| Binding errors not identified until run-time                                                                                                                                  | Binding errors identified at compile-time                                                                                                                                         |
| Synchronous - modules loaded and processed one at time                                                                                                                        | Asynchronous - processed simultaneously                                                                                                                                           |
| slower                                                                                                                                                                        | faster                                                                                                                                                                            |
| //export from file named message.js<br>module.exports = 'Hello Programmers';<br><br>// import from message.js file<br>let msg = require('./message.js');<br>console.log(msg); | //export from file named module.mjs<br>const a = 1;<br>export { a as "myvalue" };<br><br>//import from module.mjs<br>import { myvalue } frpm module.mjs;<br>console.log(myvalue); |

# Intro to Server-Side JS
- Explain purpose of Node.js JS framework
- Explain diff b/w client-side JS and server-side JS

JS
- interpreted, don't need to compile before running
- can be run on diff servers and embedded systems

Applications in Web Browser:
- w/ client-side JS, devs create rich, interactive web apps that run in web browser
1. UI rendered via HTML and CSS
2. action triggers business logic written as JS app
3. JS app sends web service request using JSON over HTTP
4. REST web server intercepts call
5. app server process web service request using server-side app (e.g. enterprise Java components) and returns to client

Applications in Server:
- Node.js apps process, and route web service requests from client
1. same
2. same
3. same
4. same
5. Node.js hosts app written in JS lang. App runs on server, not in client's web browser
![[Pasted image 20250718191523.png]]

# Creating a Web Server w/ Node.js
- Describe characteristics of Node.js
- Write a simple web server w/ Node.js

Node.js: S-S JS
- Server-side programming framework that uses JS as its programming lang
- concurrent programming
- single-threaded app that handles async I/O ops through events
- you write callback functions that handle results when async ops complete
- for scalable and concurrent server apps

***Node.js modules:***
- ***every js file is a module in Node.js***
- every module corresponds to a script file
- a package can contain one or more nodes/packages

Create simple web server: http
- With http Node.js module, you can develop an app that
	- listens to HTTP Requests and 
	- returns HTTP response messages

1. Create instance of web server
	let server = **http.createServer**(function(request, response) {
	- // createServer takes in optional callback func as param
	- // callback handles incoming request message and provides appropriate response
		let body = "Hello world!";
		response.writeHead( 200, {
			'Content-Length': body.length,
			'Content-Type': 'text/plain'
		});
		response.end(body);
	});
2. Set server instance to listen to specific port
	server.listen(8080);
	// sets the server to listen on port 8080

# Working w Node.js Modules
- describe node.js pkgs
- import node.js modules into script
- export functions and properties from a module
- access exported properties from a module

Package.json:
- package consists of one or more modules
- package.json file describes details about a node.js module
- if module has no package.json, Node.js assumed main class is named index.js

Package.json: the module manifest
- to specify diff main script for module, specify a relative path to Node.js script from module directory
{
	"name": "mod_today",
	"version": "1.0.0",
	"main": "./lib/today",
	"license": "Apache-2.0"
}

- **name** and **version fields** **form a unique identifier for module**
	- e.g. today-1.0.0
- **main field** lists a path to the main node.js script
	- e.g. today.js script is in lib subdirectory
- **license** states the module's usage rights

Importing Node.js modules:
- Use require function to import a Node.js module
	let today = require("./today");
- require statement assumes scripts have file extension of .js
- require func creates object that represents the imported Node.js module

Example: the require function
- to import a Node.js module that consists of a single script, use require function w/ relative path to script file
- if can't find, assumes the parameter string is a directory, and automatically looks for "index.js" inside the directory

Exporting functions and properties
- Each Node.js module has an implicit exports object
- To make a function or a value available to Node.js apps that import your module, add a property to exports
	exports.dayOfWeek = function () { }

Accessing exported properties
- When you import a Node.js module, the require function returns a JS object that represents an instance of the module
- To access the properties of the module, retrieve the property from the variable

# 3 Types of Node.js Modules:
- Libraries = modules, in regard to Node.js
- Libraries contain code that has bee developed that can be reused thruout app
- 3 Types modules:
	- Core
	- Local
	- Third-party

Core Node.js Modules:
- form minimal library
- contain minimal functionality needed to develop Node.js apps
- Most important of core modules:
	- http
	- path
	- fs
	- os
	- util
	- url
	- querystring
- this is why to createSever, you must require('http'); via http module
- for file I/O read write data to files, require('fs');
- os module gets computer's platform and architecture
- path module allows retrieve and manipulate directory and file paths
- util module intended for internal use, debugging, and deprecating functions
- url module divides up web address into readable parts, returning queries
- querystring provides methods to parse thru query string of URL

fs
```
const fs = require('fs');
// Asynchronously read the file 'sample.txt'
fs.readFile('sample.txt', 'utf8', (err, data) => {
    if (err) {
        console.error(err);
        return;
    }
    // Print the contents of 'sample.txt' to the console
    console.log(data);
});
```
```
const fs = require('fs');
// Read the contents of the file '/content.md' synchronously and store them in 'data'
const data = fs.readFileSync('/content.md', 'utf8');
// Print the contents of 'content.md' to the console
console.log(data);
```
os
```
let os = require('os');
console.log("Computer OS Platform Info : " + os.platform());
console.log("Computer OS Architecture Info: " + os.arch());
```
path
```
const path = require('path');
let result = path.basename('/content/index/home.html');
console.log(result); //outputs home.html to the console
```
util
```
let util = require('util');
let str = 'The loop has executed %d time(s).';
for (let i = 1; i <= 10; i++) {
    console.log(util.format(str, i)); //outputs 'The loop has executed i time(s)'
}
```
url
```
const url = require('url');
let webAddress = 'http://localhost:2000/index.html?lastName=Kent&firstName=Clark';
let qry = url.parse(webAddress, true);
let qrydata = qry.query; //returns an object: {lastName: 'Kent', firstName: 'Clark'}
console.log(qrydata.firstName); //outputs Clark
```
querystring
```
let qry = require('querystring');
let qryParams = qry.parse('lastName=Kent&firstName=Clark');
console.log(qryParams.firstName); //returns Clark
```

Local modules:
- written by you and the dev team as part of creating your Node.js app

3rd-Party modules:
- available online and have been created by back-end Node.js community
- These libraries are available to use as stated per their licenses
- either public domain or open source
- includes AsyncJS, Axios, and Express pkgs/libraries to use

# Overview of Node Package Manager
- set of tools to deal w/ modules and packages containing dependencies
- also called package-management system

Dependencies:
- Code in form of a library or a package reused in a program
- Libraries and packages contain many dependencies
- A library does not depend on code outside of it to function

Package manager responsibilities:
- Automate:
	- Finding
	- Installing
	- upgrading
	- Configuring
	- Maintaining
	- Removing
- ... Packages

- Package managers:
	- maintain database of dependencies and versioning
	- ensures software has correct dependencies

Node Package Manager (NPM)
- Default Node.js package manager
- 2 Functions:
	- Provides CLI to publish and download packages
	- Behaves as online repository of JS packages
- The repository is a database of packages that tracks package versions

package.json file:
- ALL NPM pkgs require a file named "package.json" that should be located in the project's root directory
- NPM uses package.json to determine dependencies
- Contains key-value pairs that identify the project
- MUST contain:
	- Project name
	- Project version

Local install:
- NPM packages can be installed locally or globally 
- use local install for use with packages within your application 
- Run local install command from the directory you want the package installed in
- local install is NPM's default behavior
	npm install <package_name>
	- This creates directory name node_modules with the package and its dependencies in current working directory

Global Install:
- globally installed package will be used by all apps on machine
- use judiciously
- if you have diff versions of project on machine, they will all use the globally installed packages
- might lead to compatibility issues
	npm install -g <package_name>

# Module Summary

Congratulations! You have completed this module. At this point in the course, you know: 

- Backend technologies include various types of servers and supporting infrastructures such as programming languages, frameworks, and other hardware.  
    
- Node.js is the server-side component of JavaScript. 
    
- The require statement can be called from anywhere in the app code, is bound dynamically, and is synchronous. The import statement must be called at the beginning of a file, is bound statically, and is also synchronous, as modules are loaded before execution .
    
- Client-side JavaScript is used to process front-end user interface elements, and server-side JavaScript is used to enable access to different kinds of servers and web applications. 
    
- With server-side JavaScript, Node.js applications process and route web service requests from the client. 
    
- To make a function or a value available to Node.js applications that import your module, add a property to the implicit exports object. 
    
- Core modules include bare minimum functionality, local modules are those that you create for your application, and the Node.js community creates third-party modules.
    
- A local install means only the application within the directory of the installed can access the package, whereas a global install means that any application on the machine can access the package.![[lou0wru3.png]]

```
// Conditional
if (rating > 4) {
  console.log("Highly rated!");  // executes if condition is true
} else {
  console.log("Needs improvement.");  // executes otherwise
}

// Loop
for (let tag of tags) {
  console.log(tag);  // prints each tag
}
```

```
const books = [
  { title: "JS Basics", rating: 5 },
  { title: "Node Intro", rating: 3 }
];

// Filter: Get books with rating > 4
const topBooks = books.filter(book => book.rating > 4);

// Map: Get an array of book titles
const titles = books.map(book => book.title);

// Reduce: Calculate average rating
const averageRating = books.reduce((sum, book) => sum + book.rating, 0) / books.length;

console.log(topBooks);      // [{ title: "JS Basics", rating: 5 }]
console.log(titles);        // ["JS Basics", "Node Intro"]
console.log(averageRating); // 4
```

Classes and Objects:
- constructor + this.keyword
- creating instances, with access to class functions/properties
```
class Book {
  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }
  describe() {
    return `${this.title} has a rating of ${this.rating}`;
  }
}

const b1 = new Book("Node Basics", 4.2);
console.log(b1.describe());
```

## Working with JSON
Essential for APIs—data is exchanged in JSON format.
```
let jsonData = '{"title":"Express 101","rating":5}';

const bookObj = JSON.parse(jsonData);    // convert JSON to JS object
const newJson = JSON.stringify(bookObj); // convert JS object to JSON
```

// app.js
const express = require("express");
const app = express();
app.use(express.json()); // allows app.js to parse JSON bodies

app.get("/books", (req, res) => {
	res.json([{ title: "some title", rating: 4 }]); // return hard-coded JSON response
});

app.listen(3000, () => console.log("server running port 3000"));

![[e5nuiyxu.png]]
## Understanding `req.params`, `req.query`, and `req.body`
These are ways to access incoming request data in Express.

### 1. `req.params`
```
app.get('/users/:id', (req, res) => {
  const userId = req.params.id;  // extract dynamic part from URL
  res.send(`User ID is ${userId}`);
});
```
Visiting `/users/123` sets `req.params.id` to `"123"`
- gets url dynamic [slug]

### 2. `req.query`
```
app.get('/books', (req, res) => {
  const author = req.query.author;  // extract ?author= value from query string
  res.send(`Filter by author: ${author}`);
});
```
Visiting `/books?author=JohnDoe` sets `req.query.author` to `"JohnDoe"`

### 3. `req.body`
```
app.post('/register', (req, res) => {
  const username = req.body.username;  // get value from request body
  res.send(`Username received: ${username}`);
});
```
For JSON `{ "username": "aname", "password": "pwd123" }`, `req.body.username` returns `"aname"`

