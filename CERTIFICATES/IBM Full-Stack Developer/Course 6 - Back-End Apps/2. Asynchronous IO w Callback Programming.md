
(Important Note, this is referring to older ***error-first callback pattern*** which is generally an older method of dealing with the issues of handling asynchronous responses , all of which Promises and modern async await aims to solve)

(In modern day web apps, you rarely write http.createServer()
you rarely use http.request() 
object.on() is important but not seen when using Express or Next.js, which abstracts incoming request/response streams into convenient objects (req.body, res.json()),
so you don't typically use req.on('data'), or res.on('end'), however,
under the hood, these event emitters are internally used)

(**Middleware:** Frameworks like Express use middleware to handle common tasks like body parsing, setting headers, logging, and error handling _before_ your route handler even runs, or as a centralized mechanism.)

# Asynchronous I/O
- Node.js makes all network ops in a non-blocking manner
- Every network op returns immediately
- To handle result from network call, write callback func that Node.js calls when network op completes

##### All callbacks in these notes refer specifically to Node.js Asynchronous Functions which contain callbacks
- First argument of callbacks is reserved for Error object
- e.g. request.on

Application calls http.request():
1. App calls http.request
2. this func makes call to remote web server and requests web service
3. before node.js framework receives response, it immediately returns result for HTTP.request function call
	- this result simply indicates that request message was sent successfully
	- doesn't say anything about response
- Once Node.js framework receives response from remote web server, it call callback function you defined during http.request function call

Node.js calls http.request():
- App calls custom Node.js module
- Module makes http.request function call
- Node.js framework calls remote web server's web service by sending http request msg.
- In same manner in first scenario, Nde.js framework returns value to http.request() call in Node module
	- This result simply indicates success or not
- Node module returns from the exported function call, and app continues processing to next step while response message not been sent
- remote server returns HTTP response message, and Node.js framework calls callback function defined by custom Node.js module
	- callback func handles 2 events: request.on('data') and request.on('end')

### http.request options and callback:
- calls callback function param when it receives part of the HTTP response message:
	- http.request( options, [callback func]);
- callback func optional; you can send an http request and disregard the response message (object)

### Handling response events:
- Node.js framework emits several events
- you can listen by using object.on() method and passing in event and callback func
If response is successful, data event is emitted on response object everytime data comes in :
- response.on('data', function(chunk) { buffer += chunk' });
If response finishes, 'end' event is emitted
If request fails, 'error' event is emitted
```
let request = http.request( options, function(response) { .. });

request.on('error', function(e) {
	resultCallback(e.message);
})
request.end();
```
### Handling error events:
request() method returns object of http.clientRequest
- you can write data to HTTP request message body
- make changes to the headers in the HTTP request message
- you can define event handler for errors that Node.js encounters while sending request message 

To end request:
- call clientRequest.end() to complete sending request

# Creating Callback Functions:
- how to create callback func to intercept HTTP method calls

### Propagating errors:
- As in async framework, Node.js makes extensive use of callback funcs to return the result
- Node.js modules in the SDK pass an error obj as first param in calback func
	- ***SDK here refers to the older meaning, in the context of Node.js, Node.js's standard, built-in core modules***
- if error is defined, callback handles error and cleans up any open network or database connections
- if error not defined,  callback examines result from call
### Callback w/ error handling
- if error parameter defined, print error
- Otherwise, print result
- to print temp in browser, we can print it within response.end

### Passing error obj to callback
- recall callback funcs check first param to see if error condition occurred
- e.g.
	- if parseString( buffer, function(err, res) {
		if (error) {
			resultCallback(error);
			return;
		}
		resultCallback(null, ...);
	- })
	- if parseString passes error obj, pass error to resultCallback callback func of original caller (main app)
	- set first param as null if no error

### Passing HTTP response message
- callback handler can print contents of HTTP response message body to console or log contents into database
- what if you wanted callback handler to return response message to original calling application

- you CANNOT use a return func inside the request() callback handler because Node.js might call the callback func after http.request() call completes
- basically, request() returns almost immediately, while the callback ahndling response inside it is asynchronous
- this issue is handled with modern day approaches (Promises and await/async)
#### No link b/w callback and main app
1. app calls exported func
2. the module that implements the function calls http.request so Node.js framework can make a web service call on its behalf
3. request sent successfully, framework returns control to node.js module, which returns value of successful request
4. Then node.js returns control to application to continue steps
5. server send response to Node.js framework, the framework call callback handler defined by Node.js module
- however, there is no connection b/w callback func and main application
- So how do you link the callback func to main application?

### One Callback at Each level
- when one node.js app calls a module in a non-blocking manner, the app must pprovide a callback func ton process the result
- if main app calls http.request(), it must provide a callback handler to process HTTP response msg
- if main app calls function that calls http.request(), 2 callback funcs are invovled:
	1. custom module has callback function to handle HTTP response message from http.request()
	2. main app has callback func that processes the result that is captured in the first callback func
![[Pasted image 20250719193021.png]]
![[Pasted image 20250719193550.png]]
- crucially, when using a module function that makes the http.request(), you must pass resultCallback function as parameter of module function, and use it inside http.request() function. 
	- it is your responsibility as the dev to implement error handling when response error, so you must return either null or error as first argument
- then, in the main app, you pass in the actual defined function as the resultCallback function, thereby linking the module and the mainapp to handle response. 
	- it is your responsibility to have error as first parameter

*** Note, Node.js internal modules always put the error first. for Custom, its still best practice. You are expected to have the callback function to receive an error object as its first argument.

# Issues with Callbacks
- explain why nested callbacks occur
- Explain difficulties w/ nested callbacks
- describe inversion of control
- explain difficulties with inversion of control
- identify ways to mitigate nested callbacks and inversion of control

Callback functions
- function passed as argument to another function
- used to ensure an action is executed only after result is produced
- help develop async JS
- e.g. setTimeOut( function, 3000);

Retrieval and Execution:
- Usually, async callbacks are used for accessing vals from databases, downloading images, reading files, and so on
- these resources are often provided by outside services
- callbacks wait for response, and then are executed

But what if you need callbacks to happen sequentially?
- Function nesting ==> CALLBACK HELL

Another issue w/ callbacks is INVERSION OF CONTROL

IOC:
- execution is external to your code
- many times, callbacks hand over control to 3rd-party service
- that code may have errors
- causes you to write additional code
- ensure 3rd-party code does not:
	- get called too many or too few times
	- get called too early or too late
	- lose context
	- pass back incorrect args

IoC Complications example
- ex: 3rd party code has bug where it gets call multiple times
what if callback never gets called?

Ways to mitigate:
- write comments
- split functions into smaller functions
- **use promises**
- **use async/await**

# Promises
- states of promise
- how to use with async methods

### What is a Promise?
- **an obj returned by an async method**
- States: **pending, resolved, rejected**
- Uses: API requests, I/O operations

You can create your own Promise object
### User-defined promise
const methCall = new Promise((res, rej) => {
	setTimeout(() => 
	{
		try {
			const data = fs.readFileSync(...);
			**res(data);**
		} catch(err) {
			**reject(err);**
		}
	}, 3000);
});

### Axios request
- HTTP requests, when called synchronously, can be blocking
- Many pkgs in Node ecosystem that wrap promises around HTTP requests
- Example: Axios pkg
```
const axios = require('axios').default;

const connectToUrl = (url) => {
	const req = axios.get(url);
	console.log(req); // Promise { <pending> }
	req.then(resp => {
		console.log("Fulfilled);
		console.log(resp.data);
	})
	.catch( err => P
		console.log("Rejected") // Immediately outputs "Rejected"
	});
}
connectToUrl('validurl)
connectToUrl('invalidurl');
```

Promise and .then() activity:
```
//Creating a promise method. The promise will get resolved when timer times out after 6 seconds.
let myPromise = new Promise((resolve,reject) => {
    setTimeout(() => {
      resolve("Promise resolved")
    },6000)})

//Console log before calling the promise
console.log("Before calling promise");

//Call the promise and wait for it to be resolved and then print a message.
myPromise.then((successMessage) => {
    console.log("From Callback " + successMessage)
  })

//Console log after calling the promise
  console.log("After calling promise");
```


# Working with JSON
- How to parse JavaScript Object Notation data from an HTTP message

Parse JSON data from HTTP message
- JSON is the standard format for application programming interface (API) data exchange
- Because it is the standard representation of native JavaScript objects, Node.js handles JSON easily
- key-value pairs

- Method JSON.parse() parses a JSON string to a JS object
let json = '{"result":true, "count":42}';
obj = JSON.parse(json);
console.log(obj.count); // 42
console.log(obj.result); // true
- Method JSON.stringify() converts a JS object into a JSON string
console.log(JSON.stringify({x: 5, y: 6 }));
// output: " { "x":5, "y":6 } "

# JSON Insider Viewpoint
- JSON is the defacto standard for data serialization
- it is one of the dominant formats to encode objects into a string
- specifying requirements for Node.js project
- specifying deployments for platforms as a service such as kubernetes
- JSON is a native data type in JS
- Serialization converts JSON obj into byte string
- deserialization converts byte string back to JSON
- request and response objects in cloud, REST APIs, are often in JSON, at the curl level or shell script level

# Promises, async/await, and axios requests in Node.js and Express
- use async/await syntax for clearer and more readable asynchronous code
- make HTTP requests using Axios library

Promises:
- represents eventual completion or failure
- Chains operations for better readability and manageability

Creating Promise:
- use new Promise((res, rej) =< { ... resolve(...); reject(...); ...});
- handle success and failure with resolve and reject

Chaining Multiple Async Ops in Sequence via:
### Using Promises w .then() and .catch()
- handle success with .then()
- handle errors with .catch()

Example:
- fs.promises module:
- reads a file
- provides promise-based methods for file system ops
```
const fs = require('fs').promises;

// Read the content of the file 'example.txt'
fs.readFile('example.txt', 'utf8')

// Handle resolved state of promise
.then((data) => {
// This block will execute if file is read successfully
console.log(data);
})

// Handle rejected state of the promise
.catch((err) => {
// This block will execute if there is an error reading the file
console.error('Error reading file:', err);
});
```

### Async and await in JS:
- promises can complicate the readability and structure of your code
- async/await simplifies promises;
- resembles synchronous code
- async function returns a promise
- await pauses execution until a promise resolves or rejects

#### Benefits of async/await
- Readability
- Error handling
	- **uses standard try/catch for error handling, which is more familiar to devs**
- Debugging

### Using async/await func
- simulates conditional operation
- returns success message or throws error
- uses await to call async function
- handles result/errors with try and catch
```
// async function that wraps the operation
async function myAsyncFunction() {
	// Simulating condition w/ boolean var 'success'
	let success = true;
	if (success) {
		return "success!";
	} else {
	// if condiiton false, throw error to simulate rejecting
	}
}

async function executeAsyncFunction() {
	try {
		// Await async func call to get result
		const result = await myAsyncFunction();
		console.log(result);
	} catch (error) {
		console.error(error);
	}
}
```

#### Crucially, you should await a Promise, because then it allows your function to PAUSE execution until that Promise has resolved.
##### Otherwise, if you're not waiting for something, then await keyword is useless, since you're basically just wanting synchronous coding

### Axios requests
- Promise-based HTTP client for browser and Node.js
- Simplifies sending async HTTP requests to REST endpoints
- Supports CRUD operations
- Transforms JSON data automatically w/ clean and simple API

Features of Axios:
- Promise-based
- Automatic JSON transformation
- Interceptors
- Cancellation
- Error-handling
![[Pasted image 20250720004311.png]]

Using Axios to make GET request:
- install axios using command npm install axios
- Use Axios to make HTTP GET requests
- Use axios.get method to access the data w/ response.data
```
const axios = require('axios');

axios.get('https://api.example.com/data')
.then(response => {
	console.log(response.data);
})

.catch(error => {
	console.error('Error fetching data:', error);
});
```

Using Axios to make POST request:
- import axios library

```
const axios = require('axios');

// Data to be sent. JS object info
const data = {
	name: 'John Doe',
	age: 30
};

axios.post('https://api.example.com/users', data)
.then(response => {
	console.log('User created', response.data);
})

.catch(error => {
	console.error('Error fetching data:', error);
});
```

### Using async/await w/ Axios:
- async/await handles HTTP requests efficiently
- supposedly more readable

```
const axios = require('axios');

async function postData() {
	try {
		let response = await axios.post('https://jsonplaceholder.typicode.com/posts', {
			title: 'foo', // The title of the post
			body: 'bar', // body/content of the post
			userId: 1    // user ID associated with post
		});
		console.log(response.data);
	} catch (error) {
		console.error('Error posting data:', error)
	}
}

postData();
```


# Activity Axios Promise Async:
```
// Requiring axios module for making HTTP requests

const axios = require('axios').default;

  

// Function to connect to a URL and handle the response

const connectToURL = (url) => {

    // Sending a GET request to the specified URL using axios

    const req = axios.get(url);

    // Logging the initial promise object

    console.log(req);

    // Handling the promise resolution

    req.then(resp => {

        // Logging the fulfillment message

        console.log("Fulfilled");

        // Logging the response data

        console.log(resp.data);

    })

    // Handling the promise rejection

    .catch(err => {

        // Logging the rejection message with the URL

        console.log("Rejected for url " + url);

        // Logging the error message

        console.log(err.toString());

    });

}

  

// Valid URL

connectToURL('https://raw.githubusercontent.com/ibm-developer-skills-network/lkpho-Cloud-applications-with-Node.js-and-React/master/CD220Labs/async_callback/sampleData.json');

// Invalid URL

connectToURL('https://raw.githubusercontent.com/ibm-developer-skills-network/lkpho-Cloud-applications-with-Node.js-and-React/master/CD220Labs/async_callback/sampleDate.json');
```

Notes: req and res are promise objects
- hencewhy you can call req.then() and req.catch() for its resolved and rejected values




# Module Summary

Congratulations! You have completed this module. At this point in the course, you know:

- Asynchronous network operations can be handled using callback functions in order to prevent blocking JavaScript code  
    
- A callback function must invoke another callback function to pass a message from the Node.js module back to the main application after the Node.js module receives a response message 
    
- Nested callbacks can be difficult to read and debug. Inversion of control causes trust issues when dealing with third-party code 
    
- Promise objects are most useful for operations that are time-consuming and can block resources 
    
- JSON.parse() and JSON.stringify() are two methods used to parse JSON objects


### Module 2 Glossary: Asynchronous I/O with Callback Programming

|Term|Definition|
|---|---|
|Async|`Short for “asynchronous”.`|
|Axios Package|`The axios package wraps promises around HTTP requests.  It returns a promise object.`|
|Callback Hell|`Many nested callback functions.`|
|Inversion of Control|`When the flow of control, such as the execution of instructions, is controlled by a third party.`|
|Promise|`An object in JavaScript that acts as a placeholder for an asynchronous task that is yet to be completed. It is the object that is returned from an asynchronous method. When you define a promise object in your script, instead of returning a value immediately, it returns a promise. The promise has three states, which are pending, fulfilled, and rejected.`|
|Pyramid of Doom|`Another term for “callback hell”.`|
### Module 2 Cheat Sheet: Asynchronous I/O with Callback Program

| Package/Method  | Description                                                                           | Code Example                                                                                                                                                                                                                                                              |
| --------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Async-await** | We can await promises as long as they are being called inside asynchronous functions. | 1. `const axios = require('axios').default;`<br>2. `let url = "some remote url"`<br>3. `async function asyncCall() {`<br>4.   `console.log('calling');`<br>5.   `const result = await axios.get(url);`<br>6.   `console.log(result.data);`<br>7. `}`<br>8. `asyncCall();` |

|                                       |                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Callback**                          | Callbacks are methods that are passed as parameters. They are invoked within the method to which they are passed as a parameter, conditionally or unconditionally. We use callbacks with a promise to process the response or errors. | 1. `//function(res) and function(err) are the anonymous callback functions`<br>2. `axios.get(url).then(function(res) {`<br>3.     `console.log(res);`<br>4. `}).catch(function(err) {`<br>5.     `console.log(err)`<br>6. `})`                                                                                                                                                                                                                                                                                                                                                                 |
| **Promise**                           | An object that is returned by some methods, representing eventual completion or failure. The code continues to run without getting blocked until the promise is fulfilled or an exception is thrown.                                  | 1. `axios.get(url).then(`<br>2. `//do something`<br>3. `).catch(`<br>4. `//do something`<br>5. `)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| **Promise use case**                  | Promises are used when the processing time of the function we invoke takes time like remote URL access, I/O operations file reading, etc.                                                                                             | 1. `let prompt = require('prompt-sync')();`<br>2. `let fs = require('fs');`<br>3. `const methCall = new Promise((resolve,reject)=>{`<br>4.     `let filename = prompt('What is the name of the file ?');`<br>5.     `try {`<br>6.       `const data = fs.readFileSync(filename, {encoding:'utf8', flag:'r'});`<br>7.       `resolve(data);`<br>8.     `} catch(err) {`<br>9.       `reject(err)`<br>10.     `}`<br>11. `});`<br>12. `console.log(methCall);`<br>13. `methCall.then(`<br>14.   `(data) => console.log(data),`<br>15.   `(err) => console.log("Error reading file")`<br>16. `);` |
| **object.on()**                       | It defines an event handler that the framework calls when an event occurs                                                                                                                                                             | 1. `http.request( options, function(response) {`<br>2.  `let buffer = ‘’;`<br>3.  `...`<br>4.  `response.on('data', function(chunk) {`<br>5.    `buffer += chunk;`<br>6.  `});`<br>7.  `response.on('end', function() {`<br>8.    `console.log(buffer);`<br>9.  `});`<br>10. `}).end();`                                                                                                                                                                                                                                                                                                       |
| **Callback Hell/The Pyramid of Doom** | Nested callbacks stacked below one another and waiting for the previous callback. This creates a pyramid structure that affects the readability and maintainability of the code.                                                      | 1. `const makeCake = nextStep => {`<br>2.   `buyIngredients(function(shoppingList) {`<br>3.     `combineIngredients(bowl, mixer, function(ingredients){`<br>4.       `bakeCake(oven, pan, function(batter) {`<br>5.         `decorate(icing, function(cake) {`<br>6.           `nextStep(cake);`<br>7.         `});`<br>8.       `});`<br>9.     `});`<br>10.   `});`<br>11. `};`                                                                                                                                                                                                              |
| **Axios Request**                     | The axios package handles HTTP requests and returns a promise object.                                                                                                                                                                 | 1. `const axios = require('axios').default;`<br>2. `const connectToURL=(url)=>{`<br>3.   `const req=axios.get(url);`<br>4.   `console.log(req);`<br>5.   `req.then(resp=>{`<br>6.   `console.log("Fulfilled");`<br>7.   `console.log(resp.data);`<br>8.   `})`<br>9.   `.catch(err=>{`<br>10.   `console.log("Rejected");`<br>11.   `});`<br>12. `}`<br>13. `connectToURL('valid-url')`<br>14. `connectToURL('invalid-url')`                                                                                                                                                                   |
![[Pasted image 20250720013709.png]]
![[Pasted image 20250720013720.png]]

