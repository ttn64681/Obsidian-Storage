- Software Design and Arch take place during design phase of SDLC
- SoftArch is the organization of the system
- serves as blueprint for devs
- comprised of fundamental structures and behaviors
- Serves as BASIS for COMMUNICATION among team members

Early Design Decisions
- How components interact
- Operating environment
- Design principles
- Costly to change once implemented
- Addresses non-functional aspects
	- Scalability, Maintainability, interoperability, security, and manageability

Importance:
- Communication
- Earliest design decisions
- flexibility due to changing requirements
- increases lifespan

Software arch and tech stacks
- Guides tech stack choice
- tech stacks must address non-functional capabilities
- tech stacks include:
	- software
	- prog langs
	- libraries
	- frameworks
- Architects must weigh advantages and disadvantages of tech stack choices to anticipate client needs

**Artifacts** produced during Arch Design Phase:
(Used to communicate soft des to stakeholders)
- **Software Design Doc**
	- SDD is Collection of tech specs regarding design implementation
	- Design considerations:
		- Assumptions
		- Dependencies
		- Constraints
		- Requirements
		- Objectives
		- Methodologies
- **Arch Diagrams**
	- Displays:
		- Components
		- Interactions
		- Constraints
		- Confines
		- Arch patterns
	- General reusable solutions
- **Unified Modeling Language (UML) diagrams**
	- visually communicate structures and behaviors
	- not constrained by programming lang

The staging environment replicates the production environment, but is not intended for general users.

Deployment Considerations:
- Arch drives production env choices
- Prod env is the infrastructure that runs and delivers the software
	- Servers
	- load balancers
	- databases
- What does the production environment take into account that pre-production environments do not? **Load**

# Software Design and Modeling
- Software design is a process to document:
	- structural components
	- behavioral attributes
- Models express software design using
	- Diagrams and flowcharts
	- unified modeling language (UML)

Characteristics of ***Structured design***:
Breaks down a software prob into well-organized solution elements
- structured elements: modules & sub-modules
- Modules should be:
	- Cohesive (all functionally related elements are grouped together)
	- Loosely coupled (modules are weakly associated so changes in one does not affect another)
Ex: Structure Diagram
![[Pasted image 20250624211656.png]]


Characteristics of ***Behavioral models:***
- describe what a system does but does not explain how it does it
- communicate behavior of the system
- many types of behavior UML diagrams
	- State transition diagram
		- describes diff states of a system and triggering events
	- Interaction diagram

UML Diagrams:
- visual representations to communicate arch, design, and implementation
- 2 types: structural and behavioral
- programming lang agnostic
- Pros:
	- Allow to plan behaviors and structures in advance
	- saves time and money
	- bring team members up to speed quickly
	- facilitates comm
	- navigate source code

Ex: State transition diagram
![[Pasted image 20250624212112.png]]

Ex: Interaction diagram (Sequence diagram)
- displays comm between objects w/ respect to time
![[Pasted image 20250624212257.png]]


# Object Oriented Analysis and Design
OOAD is the process of software planning based on behaviors of interacting objects
- Objects contains data, and an object can perform actions
- a generic version of an object is a "class"
- specific objects, also called "instances," are created from classes
- Class
	- blueprint for an object
	- Properties:
		- an object's data
	- Methods
		- an object's actions

- OOAD Used for a system that can be modeled by interacting objects
- allows devs to work on diff aspects of the same app at the same time
- visual UML diagrams can be made to **show both static structure** and **dynamic behavior of a system**

Class Diagrams in OOAD:
- Inheritance
![[Pasted image 20250624213702.png]]

Importances of Design and Architecture:
- know what program needs to handle
- sustainability
- prevents you from wasting coding time
- something you've built locally but not scale
- Questions Architecture answers:
	- Where is data coming from?
	- How is data getting passed in?
	- What do I do with data?
	- Who can access the data?
- Architectural considerations:
	- costs incurred for hopping networks
	- who is using my service
	- how do i manage accounts
	- what is a particular user allowed to do
	- how do services talk to each other
	- architecture is like a rough sketch
	- what. where, and scope
- planning years ahead

# Architectural Patterns (Distributed System)
Distributed System:
- A broad category / collection of independent computers spread across multiple machines, that appear to users as a single coherent system
- Contains multiple services that coordinate interactions using a communication protocol such as HTTP
- Fundamentally refer to arch patterns ->

- Peer-to-Peer
	- decentralized network of nodes that behave both as client and as server
	- no central server controlling entire network
	- Peers share resources (files, processing power) directly w/ each other
		- multiple instances of peers via sockets and ports
	- Peer-to-peer architecture is not mutually exclusive with an event-driven architecture.


- Microservices
	- apps composed of several loosely coupled services that communicate using APIs or message brokers (async messaging)
	- Each service focuses on a single business capability.
		- each folder represents an app that has its own api routes, database, frontend, etc.
	- *(e.g., User Service, Product Service, Order Service, Payment Service).*
	- *Each microservice might have its own dedicated database.*
```
    my_microservices_app/
    ├── api-gateway/         # Handles routing external requests
    │   ├── server.js
    │   └── package.json
    ├── user-service/        # Independent microservice
    │   ├── app.py
    │   └── user_db.sqlite   # Or config for a dedicated user DB
    ├── product-service/     # Independent microservice
    │   ├── server.js
    │   └── package.json
    ├── order-service/       # Another independent microservice
    │   └── ...
    ├── frontend/            # Presentation layer
    │   └── ...
    └── kubernetes/          # Deployment configurations
        ├── user-service-deployment.yaml
        ├── product-service-deployment.yaml
        └── ...
```

- Event-driven
	- have consumers that send requests to producers
```
    my_event_driven_app/
    ├── user-service/            # Producer
    │   ├── app.py
    │   └── requirements.txt
    ├── notification-service/    # Consumer
    │   ├── consumer.js
    │   └── package.json
    ├── analytics-service/       # Another Consumer (potentially in a different language)
    │   └── ...
    └── infrastructure/
        └── kafka_setup.yaml     # Configuration for the Event Broker (e.g., Docker Compose or Kubernetes)
```

- Two-tier
	- have clients that communicates w a server
	- The interface resides on the client machines and makes requests to a server for data or services
	- client-server model where the application is divided into two logical layers: the client tier and the data tier (database)
```
my_two_tier_app/
├── client_app.py        # Contains UI and all business logic
└── my_database.db       # SQLite database file (or connection config for remote
```
***`Client (UI + Logic) <---> Database (Data)`*** 
***OR*** 
***`Client (UI) <---> Server (Logic + Data)`***

- Three-tier
	- presentation, application, and data
	- enhances scalability, maintainability, and better performance for larger applications
```
    my_three_tier_app/
    ├── frontend/            # Presentation Tier
    │   ├── public/
    │   ├── src/
    │   └── package.json
    ├── backend/             # Application Tier
    │   ├── server.js
    │   └── package.json
    └── database/            # Data Tier (often just config/schema files, actual DB runs separately)
        └── schema.sql
```
***`Client (UI) <---> Application Server (Logic) <---> Database (Data)`***

- Pub-Sub
	- enables the movement of messages between different components of the system without the components being aware of each other’s identity (they are decoupled).


# Design Approaches to Application Arch

What is a component?
- an individual unit of encapsulated functionality
- serves as a part of an app in conjunction w other components
- 6 characteristics:
	- Reusable
		- reused in diff apps
	- Replaceable
		- easily replaced w another comp
	- Independent
		- doesn't have dependencies on other components
	- Extensible
		- add behavior without changing other comps
	- Encapsulated
		- bundling data and methods to hide an internal state
		- doesn't expose its specific implementation
	- Non-context specific
		- operates in diff environments
Examples:
- API
- Data Access Object (interface for database)
- Controller - determines which other comps need to be called for a particular event

**Component-based arch** - 
- decomposes design into logical components
- Higher level abstraction than OOD
- **Defines, composes, and implements loosely coupled independent components so they work together to create an app**


<hr>

Service
- designed to be deployed independently and reused by mult systems
- Solution to a business need
- Has one unique, always running instance with whom mult clients communicate
![[Pasted image 20250625071430.png]]

Examples of Services:
- a service is a component that can be deployed independently
	- checking customer's credit
	- calculating a monthly loan payment
	- processing a mortgage app

**Service oriented architecture (SOA)** - 
- loosely coupled services that communicate over a network
- Supports building distributed systems that deliver services to other apps through communication protocol


# Summary & Highlights

Congratulations! You have completed this module. At this point, you know that: 

- Software architecture functions as a blueprint and represents the importance of a good architectural design. 
    
- ***Structured design*** breaks down a software problem into well-organized smaller solution elements whereas ***behavioral models*** describe the behavior of the system without explaining how the system implements the behavior. 
    
- Developing UML diagrams saves time and money by helping developers quickly get up to speed on a project, plan features in advance of coding, and navigate source code easily. Types of UML diagrams include state transition, interaction, and class diagrams.  
    
- Objects contain data, and they also have behaviors that prescribe the actions the object can take, whereas classes are blueprints for objects.  
    
- **A service-oriented architecture (SOA)** consists of loosely coupled services that interface with each other via a communication protocol over a network. Distributed systems run on multiple services on different machines, but they appear to the end-user as a single coherent system. 
    
- An architectural pattern is a repeatable solution to an architectural problem. Types of architectural patterns include 2-tier, 3-tier, event-driven, peer-to-peer, and microservices. Two or more patterns can be combined in a single system, but some are mutually exclusive.  
    
- Application environments include development, testing or QA, staging, and production. Production environments tend to be more complex than pre-production because they must take into account non-functional requirements like **load, security, reliability, and scalability**.  
    
- Application environments can be deployed either on-premises on traditional hardware, or on public, private, or hybrid cloud platforms. 
    
- Common components needed for a production environment include a **firewall**, a **load balancer**, **web and application servers**, proxy servers, and database servers.













