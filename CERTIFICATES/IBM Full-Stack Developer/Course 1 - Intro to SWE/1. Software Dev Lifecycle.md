## **Course objectives**

After completing this course, you will be able to:

- Explain the stages of the software development lifecycle (SDLC) and elements of quality software
- Identify different approaches to software development and explore team dynamics and career opportunities
- Differentiate between front-end and back-end development and identify key technologies used
- Describe basic programming concepts and write simple Python code
- Explain the importance of software architecture and design, and use UML to communicate system structure and behavior
- Identify the roles, skills, and ethical responsibilities of software engineers

- Application dev (front-end and back-end)
- Basic Python programming
- Software design n Architecture

<hr>

What is software engineering?
- application of scientific principles to the design and creation of software
- Design, Build, Test

mid 1960s-mid 1980s:
- no proper system for software dev
- bugs
- scaling issues

1990s:
- Organized, established engineering discipline
- CASE - business, ..., project management

# Software Engineers vs Software Developers:
**Software Engineers:**
- also developers, though broader
- broad, big picture knowledge base
- systematic development process (build systems)
- focus on structure

- design, build, and maintain software systems
- write and test code
- consult w/ stakeholders, 3rd-party vendors, security specialists, and other team members

**Software Developers:**
- narrower scope
- creative approaches
- write code to implement functionality and solve **specific problems**
- building apps and features

SDLC:
- scientific approach to sofdev
- guides the sofdev process
- identifies discrete steps needed to develop software

# Software Engineers Roles:
- broad: frontend. backend, security, mobile, test, fullstack, devops, cloud, data, machine learning

- designing, envisioning, implementing, and then supporting and maintaining software through the full lifecycle
- system design architecture

# Software Development Lifecycle
- systematic process to develop high-quality software
- aims to produce software that meets requirements
- defined phases with their own processes and deliverables

- made in the mid-1960s
- deliberate approach needed to manage complex projects

Advantages:
- improves efficiency and reduces risks
- team members know what they should be working on and when
- facilitates communication among stakeholders
- team members know when development can move to the next phase
- respond to changing requirements
- solve problems early in process rather than in coding
- reduces overlapping responsibilities

6 PHASES:
1. Planning
2. Design
3. Development
4. Testing
5. Deployment
6. Maintenance

**Planning**
- requirements are gathered, analyzed, documented, and prioritized
- Purpose, Inputs/Outputs, Users, Compliance, Risk ID, Resourcing, QA, Scheduling
- Project teams identified, roles proposed
- Prototyping:
	- small-scale replica to clarify requirements
	- tests dev ideas
- Software requirements specification (SRS): Documentation
**Design**
- SRS used to develop the Software Architecture
- Architecture reviewed, and prototypes are designed for demonstration purpose
- Design Document
Development
- Design Document used to assign roles and programming tasks
Testing
- done once code is complete
- testing teams sometimes used
- manual, automated, or hybrid
- reported tracked fixed and retested
- ***Unit, Integration, System, Acceptance***
Deployment
- Tested Code or Microservice made available to users
- Users Acceptance Testing environment, then Production environment
Maintenance
- Once code deployed into production environment
- identify UI issues
- New and changing requirements
- Other bugs
- Code enhancement
- stakeholder feedback

# Building Quality Software
- **Requirement gathering (SRS)**
	- set of use cases that business needs and user-flow
	- 4 categories: functional, external & UI, system features, nonfunctional
- **Design**
	- Transforming requirements into code
	- Technical Leads breaking down requirements into sets of related components (which defines system architecture) 
	- Communicating business rules and application logic, UI design
- **Coding for Quality**
	- Clean and consistent code
	- easy to read and maintain
	- well documented
	- efficient
	- Following coding standards
	- **using linters to detect pragmatic errors**
	- commenting in code
- **Testing**
	- bug testing
	- security and performance
	- **Unit, Testing:** done by developer isolated from rest of code
	- **Integration testing:** taking component integrated w/ larger product and testing it
	-  **System testing**
	- **User acceptance testing (UAT) or Beta testing:** by users
	- Alpha (select group of stakeholders (not finished)), Beta (outside the developing environment), General Availability (stable, for all users)
- **Documenting**
	- System Documentation:
		- README, inline comments, architecture n design docs, verification info and maintenance guides
	- User documentation
		- User guides, instructional videos, manuals, online and inline help

# Requirements
- Steps of Requirement Gathering Process
- User Requirement Specification (URS)
- Software Requirement Specification (SRS)
- System Requirement Specification (SysRS)

Steps:
- identifying stakeholders
	- key personnel: decision-makers, end-users, sales, customer support, etc.
- establishing goals and objectives
	- goals: broad, long-term achievable
	- objectives: actionable, measurable actions that achieve the goal

- eliciting requirements from the stakeholders
- documenting the requirements
- analyzing and confirming the requirements
	- elicit:
		- surveys, questionnaires
	- doc:
		- align w goals easily understood
	- confirming:
		- consistency clarity

- prioritizing
	- must0have
	- highly desired
	- nice to have

**Requirements Documentation:**
- **SRS**
	- *functionalities of software*
	- *establishes benchmarks/service-levels for performance*
	- *purpose and scope*
	- *constraints, assumptions, dependencies*

	- Requirements:
		- Functional - functions of software
		- External - users and interactions w other hardware or software
		- System features - functions of the system
		- Non-functional - performance, safety, security, quality standards

	- Purpose and Scope:
		- Purpose: who has access to the SRS and How it should be used
		- Scope: Software benefits, goals, and objectives

	- Constraints, Assumptions, Dependencies:
		- Constraints: how the software must operate under given conditions
		- Assumptions: required OS or hardware
		- Dependencies: on other software products

***These are less commonly made:***
- URS
	- describe business need and end-user expectations
	- **Documents User stories:**
		- Who What Why
	- Confirmed during UAT
	- Often combined into SRS (is a subset of SRS)
- SysRS
	- Outlines requirements of the system
	- Broader than an SRS
	- Contains:
		- System capabilities
		- Interfaces and user characteristics
		- Policy
		- Regulation
		- Hardware expectation
		- Software acceptance criteria

# Software Development Methodologies
Common development methodologies:
   A process is needed to clarify communication and facilitate information sharing among team members.
- Waterfall
- V-shape momdel
- Agile

Waterfall method (original historical method, but changed)
- Stakeholder does not see product until testing phase
- Linear, sequential
V-Shape model
- 4 down - verification (design phase)
- 4 up - validation (coding phase)
- Linear, sequential
Agile
- iterative approach
- teams work in cycles or sprints (1-4 weeks long)
- unit testing happens each sprint
- end of sprint is demo and feedback
- after demo, sprint repeats
- after several sprint cycles, MVP made
- 4 core values: "Agile Manifesto"
	- Individuals and interactions over processes and tools
	- Working software over comprehensive documentation
	- Responding to change over following a plan
	- Customer collaboration over contract negotiation

# Sequential vs Iterative
Sequential: Waterfall and V-Shape Model
- sequential
- product is made before customer feedback
Waterfall:
- Pros:
	- team members understand their roles
	- easier to estimate budget and allocate resources
	Cons:
	- Lack flexibility
	- Change is hard to accommodate
V-Shape:
- Pros:
	- easy to use
	- test plans designed upfront saves development and testing time
- Cons:
	- Rigid
	- Doesn't accommodate changing requirements
Iterative: Agile
- cyclical
- quick short bursts of development
- Pros:
	- changing requirements handled easily
	- Feedback incorporated regularly
- Cons:
	- Project scope not defined
	- Budgeting and resource allocation is challenging

# Software Versions:
- indicates new software, updates, and patches
- version numbers can be short or long, w/ 2,3, or 4 sets
- 1.0 is first release
- some use dates Ubuntu 18.04.2 (2018 april, 2nd change)

Version Numbers meaning -
   Some version numbers follow semantic numbering system and have 4 parts separated by period
   - First num: major changes to software, ex: new release
   - Second num: minor changes
   - Third num: patches or minor bug fixes
   - Fourth num: build numbers, build dates, and less signif changes
- Identified in the 'Help' or 'About' Section of software

# Software Testing
- Functional, Non-functional, Regression Testing
- Integrate quality tests/checks during SDLC
- Verify functionality and requirements
	- Steps, Data, Inputs, Expected Output
- Test cases should be written after requirements are finalized

Types:
- Functional
	- Black Box Testing: not looking at source code
		- only concerned with inputs and corresponding outputs
		- manual or automated
		- **checks usability and accessibility**
- Nonfunctional
	- Checks:
		- Performance, Security, Scalability, and Availability
		- How does app behave under stress?
		- What happen when many users log in at same time?
		- Are instructions consistent with behavior?
		- Does application behave under diff OSs?
		- How does app handle disaster recovery?
		- How secure?
- Regression
	- Checks:
		- **Confirms changes don't break app**
		- Occurs after fixes such as a change in requirements or when defects are fixed
	- Choosing test cases for regression testing:
		- Frequent defects
		- Frequently used functionality
		- Features w recent changes
		- Complex cases
		- Edge cases
		- Randomly successful or failed cases

**Testing Levels:**
- **Unit**
	- Test a module of code
	- Occurs during build phase of SDLC
	- Eliminate errors before integration w/ other modules
- **Integration**
	- Identify errors introduced when 2 or more modules are combined
	- Type of black-box test
	- Occurs after modules are combined into the larger application

	- Exposes bugs when modules interact w/ each other
	- databases and hardware interaction
- System
	- Evaluate System's Compliance w/ SRS
	- Validate the system as a fully completed project
	- Functional and nonfunctional
	- Done in staging environment, similar to production environment]
- Acceptance
	- Formal testing w/ respect to user needs, requirements, and business processes
	- Determines whether system satisfies needs of 
		- users
		- customers
		- stakeholders

# Software Documentation:
- Written Assets, Video Assets, Graphical Assets
- Applicable to all phases of SDLC
- For users, devs, QA engineers, system admins, and stakeholders

Product vs Process Documentation
Product
- Relates to Product functionality
Process
- Describes how to complete a task

Types of Product Documentation
- Requirements
	- Planning phase of SDLC: Intended for dev team including devs, architects, and QA. **Describes expected features and functionality**
		- Includes SRS, SysRS, and URS
- Design
	- Written by architects and dev team to explain **how software will be built to meet requirements**
		- Consists of both conceptual and technical design docs
- Technical
	- Written in the code to help devs read code
		- Comments embedded in code and working papers that explain how code works, documents that record ideas and thoughts during implementation
- QA
	- Pertains to the testing team's strategy progress, and metrics
		- Test plans, test data, test scenarios, test cases, test strategies, and traceability matrices (map test cases to their requirements)
- User
	- Intended for end-users to explain how to operate software or help install and troubleshoot system
		- FAQs, installation and help guides, tutorials, and user manuals

Standard Operating Procedures (SOP Doc)
- accompanies process documentation
- step-by-step instructions on how to accomplish common yet complex tasks
- e.g. org specific instructions for check in code to a repository
- Types of SOPs:
	- Flowcharts
	- Hierarchical
	- Step-by-step

Updating Documentation
- must be up to date
- During maintenance phase
- documentation should be reviewed and  updated periodically

# Roles in Software Engineering Projects
Common Roles depending on methodologies of SD
Traditional Role / Agile Equivalent
- Project manager/ Scrum master
	- Planning, scheduling, and budgeting
	- Allocating Personnel and resources
	- Executing the software plan
	- Team communication
	/
	- Less on planning, Ensure team success 
	- Individual success
	- Prioritize people over process
	- focused on facilitating communication
- Stakeholder
	- **Interested parties who are affected by the software product**
		- Customer, end-users, decision-maker
	- Responsibilities:
		- Defines requirements
		- Provide feedback on requirements implementation
		- May participate in beta and acceptance testing
- System/ Software/ Solutions architect
	- **Designs, describes, and communicates architecture of a project to team members**
	- Responsibilities:
		- Designs inner structure of software
		- Designs technical aspects of software
		- Provides technical support regarding the architecture throughout SDLC stages
- UX Designer
	- **Balances making software interface intuitive yet also robust**
	- Responsibilities:
		- How software communicates functionality to the user
		- How the user interacts with the software
- Developer
	- **Writes the code that powers the software**
	- Responsibilities:
		- Implement architecture in design docs
		- Incorporate SRS requirements
		- Employ UX designs
- Tester/ QA engineer
	- Ensures quality of the product by testing to see if software meets requirements
	- Responsibilities: 
		- Writes and execute test cases
		- Provides feedback to dev teams
- **Site reliability/ Ops engineer**
	- Bridges software dev and operations
	- Responsibilities:
		- Tracks and communicates incidents
		- Automates systems, procedures, and processes
		- Troubleshoot
		- Ensures product reliability
- Product manager/ Product owner
	- Understands requirements and end-user needs
	- Responsibilities:
		- Leads development efforts
		- Ensures product provides value to the customer
- Technical writer/ Information developer
	- Writes docs for end-user
	- Technical material --> Non-technical audience
		- Responsibilities:
			- Writes user manuals
			- Writes reports
			- Writes white papers
			- Writes press releases

Product manager, Tech Leads, QUA/Test Engineers, UX Designers, Sales teams, Marketing teams, Determine customer needs, identify innovations

Project Manager
	Sets up timelines
	Helps meet goals
	Manages roadblocks
	Keeps stakeholders up to date
Product Manager
	Maintains Jira or other tool
Software Engineer
	Focus on architecture and big picture
	Some may write code
	May work together and collaborate instead of waterfall approach
	brainstorming sessions
	group chats
UX Designers and UX Engineers
	Figma specs
	Collaborates w initial drafts
	Creates mocks for implementation
	Researches and gets feedback from customers and users
QA Engineer
	Tests apps
	may create detailed testing doc
	understand what needs to be fixed
Product Managers/Owners
	Give guidance on what to build
	Discuss trade-offs, timelines, and expectations
	May work inside company
	can clarify refinements for test schedules or pain points
Site Reliability Engineers
	Work w/ SysAdmins
	Deploy the software and get it running
	work w test engineers for end-to-end testing


# Summary & Highlights

Congratulations! You have completed this module. At this point, you know: 

- Software engineering is the application of scientific principles to the design and creation of software. 
    
- Responsibilities of a software engineer include designing, building, and maintaining software systems.  
    
- Using the SDLC can improve efficiency and reduce risks by:  
    
- letting team members know what they should be working on and when  
    
- facilitating communication between the customer, other stakeholders, and the development team 
    
- letting stakeholders know where they fit into that process and  
    
- letting cross-domain teams know when they have completed their tasks so development can move to the next phase.   
    
- Common software engineering processes are requirements gathering, design, coding, testing, releasing, and documenting. 
    
- The requirement gathering process entails identifying stakeholders, establishing goals and objectives, eliciting requirements from the stakeholders, documenting the requirements, analyzing, prioritizing, and confirming the requirements. 
    
- An SRS is a document that captures the functionalities that the software should perform and also establishes benchmarks or service levels for its performance. 
    
- A URS is a subset of the SRS that details user specification requirements. 
    
- The SysRS contains the same information as an SRS, but can also additionally include system capabilities, interfaces, and user characteristics, policy requirements, regulation requirements, personnel requirements, performance requirements, security requirements, and system acceptance criteria. 
    
- Waterfall, V-shape model, and agile are all different methodologies for implementing the software development life cycle. 
    
- Functional testing is concerned with inputs and corresponding outputs of the system under test, non-functional testing tests for attributes such as performance, security, scalability, and availability. Whereas regression testing confirms that a recent change to the application, such as a bug fix, does not adversely affect already existing functionality. 
    
- Types of documentation include requirements, design, technical, quality assurance, and user. 
    
- There are many different roles involved in a software engineering project. Some of them include project manager or scrum master, stakeholder, system or software architect, UX designer, software developer, tester or QA engineer, site reliability or Ops engineer, product manager or owner, and technical writer or information developer.








